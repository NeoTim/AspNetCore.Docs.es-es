---
title: Migrar de ASP.NET Core 2,2 a 3,0
author: rick-anderson
description: Obtenga información sobre cómo migrar un proyecto ASP.NET Core 2,2 a ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 01/21/2020
no-loc:
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 142ef4ed7776a213fec6528839555001436ebda3
ms.sourcegitcommit: eca76bd065eb94386165a0269f1e95092f23fa58
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/24/2020
ms.locfileid: "76727184"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrar de ASP.NET Core 2,2 a 3,0

Por [Scott Addie](https://github.com/scottaddie) y [Rick Anderson](https://twitter.com/RickAndMSFT)

En este artículo se explica cómo actualizar un proyecto ASP.NET Core 2,2 existente a ASP.NET Core 3,0.

## <a name="prerequisites"></a>Prerequisites

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio para Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Actualización de la versión del SDK de .NET Core en global.json

Si la solución se basa en un archivo [global. JSON](/dotnet/core/tools/global-json) para tener como destino una versión de SDK de .net Core específica, actualice su propiedad `version` a la versión 3,0 instalada en el equipo:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Actualizar el archivo de proyecto

### <a name="update-the-target-framework"></a>Actualización de la plataforma de destino

ASP.NET Core 3,0 y versiones posteriores solo se ejecutan en .NET Core. Establezca el [moniker de la plataforma de destino (TFM)](/dotnet/standard/frameworks) en `netcoreapp3.0`:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Quitar referencias de paquetes obsoletas

No se produce un gran número de paquetes NuGet para ASP.NET Core 3,0. Estas referencias de paquete deben quitarse del archivo de proyecto. Considere el siguiente archivo de proyecto para una aplicación Web ASP.NET Core 2,2:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

El archivo de proyecto actualizado para ASP.NET Core 3,0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

El archivo de proyecto actualizado ASP.NET Core 3,0:

* En `<PropertyGroup>`:
  * Actualiza el TFM a `netcoreapp3.0`
  * Quita el elemento `<AspNetCoreHostingModel>`. Para obtener más información, vea [modelo de hospedaje en proceso](#in-process-hosting-model) en este documento.

* En `<ItemGroup>`:
  * se quita `Microsoft.AspNetCore.App`. Para obtener más información, vea [referencia de Framework](#framework-reference) en este documento.
  * `Microsoft.AspNetCore.Razor.Design` se quita y en la siguiente lista de paquetes ya no se generan.

Para ver la lista completa de los paquetes que ya no se generan, seleccione la siguiente lista de Expand:

<details>
    <summary>Haga clic para expandir la lista de paquetes que ya no se generan</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft. AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore.SignalR.Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net. http. Headers</li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Revisar cambios importantes

[Revisar cambios importantes](#break)

### <a name="framework-reference"></a>Referencia de Framework

Las características de ASP.NET Core disponibles a través de uno de los paquetes enumerados anteriormente están disponibles como parte de la `Microsoft.AspNetCore.App` marco de trabajo compartido. El *marco compartido* es el conjunto de ensamblados (archivos *.dll*) que se instalan en la máquina e incluye un componente de entorno de ejecución y un paquete de destino. Para más información, consulte este artículo sobre el [marco de trabajo compartido](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Los proyectos que tienen como destino el SDK de `Microsoft.NET.Sdk.Web` hacen referencia implícitamente al marco `Microsoft.AspNetCore.App`.

  No se requieren referencias adicionales para estos proyectos:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Los proyectos que tienen como destino `Microsoft.NET.Sdk` o `Microsoft.NET.Sdk.Razor` SDK deben agregar un `FrameworkReference` explícito a `Microsoft.AspNetCore.App`:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Compilaciones dependientes de Framework mediante Docker

Las compilaciones dependientes del marco de trabajo de aplicaciones de consola que usan un paquete que depende de la ASP.NET Core [marco compartido](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) pueden dar el siguiente error de tiempo de ejecución:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App` es el marco de trabajo compartido que contiene el tiempo de ejecución de ASP.NET Core y solo está presente en la imagen de Docker [dotnet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) . El SDK de 3,0 reduce el tamaño de las compilaciones dependientes del marco de trabajo mediante ASP.NET Core sin incluir copias duplicadas de las bibliotecas que están disponibles en el marco de trabajo compartido. Se trata de un ahorro potencial de hasta 18 MB, pero requiere que el tiempo de ejecución de ASP.NET Core esté presente o instalado para ejecutar la aplicación.

Para determinar si la aplicación tiene una dependencia (directa o indirecta) en el ASP.NET Core marco compartido, examine el archivo *runtimeConfig. JSON* generado durante una compilación o publicación de la aplicación. El siguiente archivo JSON muestra una dependencia en el ASP.NET Core marco compartido:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Si la aplicación usa Docker, use una imagen base que incluya ASP.NET Core 3,0. Por ejemplo, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Agregar referencias de paquete para los ensamblados quitados

ASP.NET Core 3,0 quita algunos ensamblados que antes formaban parte de la referencia de paquete de `Microsoft.AspNetCore.App`. Para visualizar qué ensamblados se quitaron, compare las dos carpetas compartidas de .NET Framework. Por ejemplo, una comparación de las versiones 2.2.7 y 3.0.0:

![comparación de ensamblados de Marcos compartidos](22-to-30/_static/assembly-diff.png)

Para seguir usando las características proporcionadas por los ensamblados quitados, haga referencia a las versiones 3,0 de los paquetes correspondientes:

* Una aplicación web generada por una plantilla con **cuentas de usuario individuales** requiere la adición de los siguientes paquetes:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft. EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Para obtener más información sobre cómo hacer referencia al paquete específico del proveedor de bases de datos, vea [proveedores de bases de datos](/ef/core/providers/index).

* Interfaz de usuario de identidad

  Se puede Agregar compatibilidad con la [interfaz de usuario de identidad](xref:security/authentication/identity) haciendo referencia al paquete [Microsoft. AspNetCore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Servicios de SPA

  * [Microsoft.AspNetCore.SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* La compatibilidad &ndash; la autenticación para flujos de autenticación de terceros están disponibles como paquetes NuGet:

  * OAuth de Facebook ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Autenticación de la cuenta Microsoft ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Autenticación de OpenID Connect ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Token de portador de OpenID Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Autenticación WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Compatibilidad con la negociación de contenido y el formato de `System.Net.HttpClient` &ndash; el paquete NuGet [Microsoft. Aspnet. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) proporciona una extensibilidad útil para `System.Net.HttpClient` con las api como `ReadAsAsync` y `PostJsonAsync`.

* La compilación en tiempo de ejecución de Razor &ndash; admite la compilación en tiempo de ejecución de vistas y páginas de Razor ahora forma parte de [Microsoft. AspNetCore. Mvc. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Compatibilidad de MVC `Newtonsoft.Json` (Json.NET) &ndash; compatibilidad con el uso de MVC con `Newtonsoft.Json` ahora forma parte de [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>Cambios de inicio

En la imagen siguiente se muestran las líneas eliminadas y modificadas en una ASP.NET Core 2,2 Razor Pages aplicación web:

![las líneas eliminadas y modificadas en una aplicación Web de Razor ASP.NET Core 2,2](22-to-30/_static/startup2.2.png)

En la imagen anterior, el código eliminado se muestra en rojo. El código eliminado no muestra el código de las opciones de la cookie, que se eliminó antes de comparar los archivos.

En la imagen siguiente se muestran las líneas agregadas y modificadas en una ASP.NET Core 3,0 Razor Pages aplicación web:

![las líneas agregadas y modificadas en una aplicación Web de Razor ASP.NET Core 3,0](22-to-30/_static/startup3.0.png)

En la imagen anterior, el código agregado se muestra en verde. Para obtener información sobre los cambios siguientes:

* `services.AddMvc` a `services.AddRazorPages`, consulte [registro del servicio MVC](#mvc-service-registration) en este documento.
* `CompatibilityVersion`, vea <xref:mvc/compatibility-version>.
* `IHostingEnvironment` a `IWebHostEnvironment`, consulte [este anuncio de github](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization` se agregó a las plantillas para mostrar que se debe agregar el middleware de autorización de pedidos. Si la aplicación no usa la autorización, puede quitar de forma segura la llamada a `app.UseAuthorization`.
* `app.UseEndpoints`, consulte [Razor pages](#razor-pages) o [Migrate startup. Configure](#migrate-startupconfigure) en este documento.

### <a name="analyzer-support"></a>Compatibilidad con analizador

Los proyectos que tienen como destino `Microsoft.NET.Sdk.Web` analizadores de referencia implícitamente que se enviaron previamente como parte del paquete [Microsoft. AspNetCore. Mvc. analizadores](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . No se requieren referencias adicionales para habilitarlas.

Si su aplicación usa [analizadores de API](xref:web-api/advanced/analyzers) previamente enviados mediante el paquete [Microsoft. AspNetCore. Mvc. API. analizadores](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , edite el archivo de proyecto para que haga referencia a los analizadores que se incluyen como parte del SDK Web de .net Core:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Biblioteca de clases de Razor

Los proyectos de biblioteca de clases de Razor que proporcionan los componentes de interfaz de usuario para MVC deben establecer la propiedad `AddRazorSupportForMvc` en el archivo de proyecto:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Modelo de hospedaje en proceso

Los proyectos tienen como valor predeterminado el [modelo de hospedaje en proceso](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) en ASP.net Core 3,0 o posterior. Opcionalmente, puede quitar la propiedad `<AspNetCoreHostingModel>` en el archivo de proyecto si su valor es `InProcess`.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configuración

Migre la configuración de Kestrel al generador de hosts web proporcionado por `ConfigureWebHostDefaults` (*Program.CS*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Si la aplicación crea el host manualmente con `HostBuilder`, llame a `UseKestrel` en el generador de hosts Web en `ConfigureWebHostDefaults`:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>El middleware de conexión reemplaza los adaptadores de conexión

Los adaptadores de conexión (`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`) se han quitado de Kestrel. Reemplace los adaptadores de conexión por el middleware de conexión. El middleware de conexión es similar al middleware HTTP en la canalización de ASP.NET Core, pero para las conexiones de nivel inferior. HTTPS y registro de conexiones:

* Se han pasado de los adaptadores de conexión al middleware de conexión.
* Estos métodos de extensión funcionan como en versiones anteriores de ASP.NET Core. 

Para obtener más información, consulte [el ejemplo de TlsFilterConnectionHandler en la sección ListenOptions. Protocols del artículo Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Abstracciones de transporte que se movieron y hicieron públicas

La capa de transporte de Kestrel se ha expuesto como una interfaz pública en `Connections.Abstractions`. Como parte de estas actualizaciones:

* se han quitado `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` y los tipos asociados.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> se ha pasado de <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> a las opciones de transporte.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode` se quitó de <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>.

Para obtener más información, consulte los siguientes recursos de GitHub:

* [Abstracciones de red de cliente/servidor (dotnet/AspNetCore #10308)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Implementar una nueva abstracción de escucha de cimientos y volver a Kestrel en la parte superior (dotnet/AspNetCore #10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kestrel encabezados de finalizador de solicitud

En el caso de las aplicaciones destinadas a versiones anteriores de ASP.NET Core:

* Kestrel agrega encabezados de finalizador fragmentados de HTTP/1.1 a la colección de encabezados de solicitud.
* Los finalizadores están disponibles después de leer el cuerpo de la solicitud hasta el final.

Esto provoca algunos problemas sobre la ambigüedad entre encabezados y finalizadores, por lo que los finalizadores se han desplazado a una nueva colección (`RequestTrailerExtensions`) en 3,0.

Los finalizadores de solicitudes HTTP/2 son:

* No disponible en ASP.NET Core 2,2.
* Disponible en 3,0 como `RequestTrailerExtensions`.

Hay nuevos métodos de extensión de solicitud para tener acceso a estos finalizadores. Al igual que con HTTP/1.1, los finalizadores están disponibles después de leer el cuerpo de la solicitud hasta el final.

En la versión 3,0, están disponibles los siguientes métodos de `RequestTrailerExtensions`:

* `GetDeclaredTrailers` &ndash; obtiene el encabezado de `Trailer` de la solicitud que muestra los finalizadores que se esperan después del cuerpo.
* `SupportsTrailers` &ndash; indica si la solicitud admite encabezados de finalizador de recepción.
* `CheckTrailersAvailable` &ndash; comprueba si la solicitud admite finalizadores y si están disponibles para su lectura. En esta comprobación no se da por hecho que hay finalizadores para leer. Es posible que no haya finalizaciones de lectura aunque este método devuelva `true`.
* `GetTrailer` &ndash; obtiene el encabezado final solicitado de la respuesta. Compruebe `SupportsTrailers` antes de llamar a `GetTrailer`, o puede producirse un <xref:System.NotSupportedException> si la solicitud no admite encabezados finales.

Para obtener más información, consulte [colocar finalizadores de solicitudes en una colección independiente (dotnet/AspNetCore #10410)](https://github.com/dotnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO deshabilitado

`AllowSynchronousIO` habilita o deshabilita las API de e/s sincrónicas, como `HttpRequest.Body.Read`, `HttpResponse.Body.Write`y `Stream.Flush`. Estas API son un origen de colapso de subprocesos que conduce a bloqueos de la aplicación. En la versión 3.0, `AllowSynchronousIO` se ha deshabilitado de manera predeterminada. Para obtener más información, consulte [la sección de e/s sincrónica en el artículo de Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Si es necesaria la e/s sincrónica, se puede habilitar configurando la opción `AllowSynchronousIO` en el servidor que se está usando (cuando se llama a `ConfigureKestrel`, por ejemplo, si se usa Kestrel). Tenga en cuenta que los servidores (Kestrel, TestServer, etc.) tienen su propia opción `AllowSynchronousIO` que no afectará a otros servidores. La e/s sincrónica se puede habilitar para todos los servidores en cada solicitud mediante la opción `IHttpBodyControlFeature.AllowSynchronousIO`:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Si tiene problemas con las implementaciones de <xref:System.IO.TextWriter> u otras secuencias que llaman a las API sincrónicas en [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), llame a la nueva API <xref:System.IO.Stream.DisposeAsync*> en su lugar.

Para obtener más información, vea [[anuncio] AllowSynchronousIO deshabilitado en todos los servidores (dotnet/AspNetCore #7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Se quitó el ensamblado Microsoft. AspNetCore. Server. Kestrel. https

En ASP.NET Core 2,1, el contenido de *Microsoft. AspNetCore. Server. Kestrel. https. dll* se ha migrado a *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. Se trata de una actualización no interrumpida mediante atributos `TypeForwardedTo`. En 3,0, se han quitado el ensamblado *Microsoft. AspNetCore. Server. Kestrel. https. dll* vacío y el paquete NuGet.

Las bibliotecas que hacen referencia a [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) deben actualizar las dependencias ASP.NET Core a 2,1 o posterior.

Las aplicaciones y bibliotecas que tienen como destino ASP.NET Core 2,1 o posterior deben quitar las referencias directas al paquete [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Compatibilidad con Newtonsoft. JSON (Json.NET)

Como parte del trabajo de [mejorar el ASP.net Core compartidos Framework](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), se ha quitado [Newtonsoft. JSON (JSON.net)](https://www.newtonsoft.com/json/help/html/Introduction.htm) de la ASP.net Core marco de trabajo compartido.

El serializador JSON predeterminado para ASP.NET Core es ahora <xref:System.Text.Json>, que es nuevo en .NET Core 3,0. Considere la posibilidad de usar `System.Text.Json` cuando sea posible. Es de alto rendimiento y no requiere una dependencia de biblioteca adicional. Sin embargo, dado que `System.Text.Json` es nuevo, es posible que actualmente falten características que la aplicación necesita. Para obtener más información, consulte [How to Migrate from Newtonsoft. JSON to System. Text. JSON](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-opno-locsignalr-project"></a>Uso de Newtonsoft. JSON en un proyecto ASP.NET Core 3,0 SignalR

* Instale [Microsoft.AspNetCore.SignalR.Paquete NuGet Protocols.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson).

* En el cliente, encadenar una llamada al método `AddNewtonsoftJsonProtocol` a la instancia de `HubConnectionBuilder`:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chatHub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* En el servidor, encadenar una llamada de método `AddNewtonsoftJsonProtocol` a la llamada al método `AddSignalR` en `Startup.ConfigureServices`:

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Uso de Newtonsoft. JSON en un proyecto de MVC ASP.NET Core 3,0

* Instale el paquete [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

* Actualice `Startup.ConfigureServices` para llamar a `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson` es compatible con los nuevos métodos de registro del servicio MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json` configuración se puede establecer en la llamada a `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**Nota:** Si el método de `AddNewtonsoftJson` no está disponible, asegúrese de que ha instalado el paquete [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) . Un error común es instalar el paquete [Newtonsoft. JSON](https://www.nuget.org/packages/Newtonsoft.Json/) en lugar del paquete [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

## <a name="mvc-service-registration"></a>Registro del servicio MVC

ASP.NET Core 3,0 agrega nuevas opciones para registrar escenarios MVC dentro de `Startup.ConfigureServices`.

Hay disponibles tres nuevos métodos de extensión de nivel superior relacionados con los escenarios MVC en `IServiceCollection`. Las plantillas usan estos nuevos métodos en lugar de `AddMvc`. Sin embargo, `AddMvc` continúa comportándose como en versiones anteriores.

En el ejemplo siguiente se agrega compatibilidad con controladores y características relacionadas con la API, pero no vistas o páginas. La plantilla de API usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

En el ejemplo siguiente se agrega compatibilidad con controladores, características relacionadas con la API y vistas, pero no páginas. La plantilla aplicación web (MVC) utiliza este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

En el ejemplo siguiente se agrega compatibilidad con Razor Pages y compatibilidad mínima con el controlador. La plantilla de aplicación Web usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

También se pueden combinar los nuevos métodos. El ejemplo siguiente es equivalente a llamar a `AddMvc` en ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Código de inicio de enrutamiento

Si una aplicación llama a `UseMvc` o `UseSignalR`, migre la aplicación al [enrutamiento del punto de conexión](xref:fundamentals/routing) , si es posible. Para mejorar la compatibilidad del enrutamiento de puntos de conexión con versiones anteriores de MVC, hemos revertido algunos de los cambios en la generación de direcciones URL introducidos en ASP.NET Core 2,2. Si experimenta problemas al usar el enrutamiento de puntos de conexión en 2,2, espere mejoras en ASP.NET Core 3,0 con las siguientes excepciones:

* Si la aplicación implementa `IRouter` o hereda de `Route`, use [DynamicRouteValuesTransformer](https://github.com/dotnet/AspNetCore.Docs/issues/12997) como reemplazo.

* Si la aplicación accede directamente a `RouteData.Routers` dentro de MVC para analizar las direcciones URL, puede reemplazarlo por el uso de `LinkParser.ParsePathByEndpointName`. 
 * Defina la ruta con un nombre de ruta.
 * Use `LinkParser.ParsePathByEndpointName` y pase el nombre de la ruta deseada.

El enrutamiento de puntos de conexión admite la misma sintaxis de patrón de ruta y características de creación de patrones de ruta que `IRouter`. El enrutamiento de puntos de conexión admite `IRouteConstraint`. El enrutamiento de puntos de conexión admite `[Route]`, `[HttpGet]`y los demás atributos de enrutamiento de MVC.

Para la mayoría de las aplicaciones, solo `Startup` requiere cambios.

### <a name="migrate-startupconfigure"></a>Migrar startup. Configure

Consejos generales:

* Agregue `UseRouting`.
* Si la aplicación llama a `UseStaticFiles`, coloque `UseStaticFiles` **antes** de `UseRouting`.
* Si la aplicación usa características de autenticación y autorización como `AuthorizePage` o `[Authorize]`, coloque la llamada a `UseAuthentication` y `UseAuthorization`: **After**, `UseRouting` y `UseCors`, pero antes de `UseEndpoints`:

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Reemplace `UseMvc` o `UseSignalR` por `UseEndpoints`.
* Si la aplicación usa escenarios de [CORS](xref:security/cors) , como `[EnableCors]`, coloque la llamada a `UseCors` antes de cualquier otro middleware que use CORS (por ejemplo, coloque `UseCors` antes de `UseAuthentication`, `UseAuthorization`y `UseEndpoints`).
* Reemplace `IHostingEnvironment` por `IWebHostEnvironment` y agregue una instrucción `using` para el espacio de nombres <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>.
* Reemplace `IApplicationLifetime` por <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> espacio de nombres).
* Reemplace `EnvironmentName` por <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> espacio de nombres).

El código siguiente es un ejemplo de `Startup.Configure` en una aplicación típica de ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Después de actualizar el código de `Startup.Configure` anterior:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Para la mayoría de las aplicaciones, las llamadas a `UseAuthentication`, `UseAuthorization`y `UseCors` deben aparecer entre las llamadas a `UseRouting` y `UseEndpoints` para ser efectivas.

### <a name="health-checks"></a>Comprobaciones de estado

Las comprobaciones de estado utilizan el enrutamiento de puntos de conexión con el host genérico. En `Startup.Configure`, llame a `MapHealthChecks` en el generador de puntos de conexiones con la dirección URL del punto de conexión o la ruta de acceso relativa:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Los puntos de conexión de las comprobaciones de estado pueden:

* Especificar uno o más hosts o puertos permitidos.
* Requerir autorización.
* Requerir CORS.

Para más información, consulte <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Guía de middleware de seguridad

La compatibilidad con la autorización y CORS está unificada en torno al enfoque de [middleware](xref:fundamentals/middleware/index) . Esto permite el uso del mismo middleware y la misma funcionalidad en estos escenarios. En esta versión se proporciona un middleware de autorización actualizado, y el middleware CORS se ha mejorado para que pueda comprender los atributos usados por los controladores MVC.

#### <a name="cors"></a>CORS

Anteriormente, CORS podía ser difícil de configurar. El middleware se proporcionó para su uso en algunos casos de uso, pero los filtros de MVC debían usarse **sin** el middleware en otros casos de uso. Con ASP.NET Core 3,0, se recomienda que todas las aplicaciones que requieren CORS usen el middleware de CORS en tándem con el enrutamiento de puntos de conexión. `UseCors` se puede proporcionar con una directiva predeterminada, y los atributos `[EnableCors]` y `[DisableCors]` se pueden usar para invalidar la directiva predeterminada cuando sea necesario.

En el ejemplo siguiente:

* CORS está habilitado para todos los puntos de conexión con el `default` Directiva con nombre.
* La clase `MyController` deshabilita CORS con el atributo `[DisableCors]`.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

En versiones anteriores de ASP.NET Core, se proporcionaba compatibilidad con la autorización mediante el atributo `[Authorize]`. El middleware de autorización no estaba disponible. En ASP.NET Core 3,0, se requiere middleware de autorización. Se recomienda colocar el middleware de autorización de ASP.NET Core (`UseAuthorization`) inmediatamente después de `UseAuthentication`. El middleware de autorización también puede configurarse con una directiva predeterminada, que se puede invalidar.

En ASP.NET Core 3,0 o posterior, se llama a `UseAuthorization` en `Startup.Configure`y el `HomeController` siguiente requiere un usuario con sesión iniciada:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Al usar el enrutamiento de punto de conexión, se recomienda no configurar `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` y, en su lugar, confiar en el middleware de autorización.  Si la aplicación usa un `AuthorizeFilter` como filtro global en MVC, se recomienda refactorizar el código para proporcionar una directiva en la llamada a `AddAuthorization`.

El `DefaultPolicy` se configura inicialmente para requerir autenticación, por lo que no se requiere ninguna configuración adicional. En el ejemplo siguiente, los puntos de conexión de MVC se marcan como `RequireAuthorization` de modo que todas las solicitudes deben ser autorizadas en función de la `DefaultPolicy`. Sin embargo, el `HomeController` permite el acceso sin que el usuario inicie sesión en la aplicación debido a `[AllowAnonymous]`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Autorización para puntos de conexión específicos

La autorización también puede configurarse para clases específicas de puntos de conexión. El código siguiente es un ejemplo de conversión de una aplicación MVC que configuró una `AuthorizeFilter` global en una aplicación con una directiva específica que requiere autorización:

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

También se pueden personalizar las directivas. La `DefaultPolicy` está configurada para requerir autenticación:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Como alternativa, se pueden configurar todos los puntos de conexión para requerir la autorización sin `[Authorize]` o `RequireAuthorization` mediante la configuración de un `FallbackPolicy`. El `FallbackPolicy` es diferente del `DefaultPolicy`. `[Authorize]` o `RequireAuthorization`desencadena el `DefaultPolicy`, mientras que el `FallbackPolicy` se desencadena cuando no se establece ninguna otra directiva. `FallbackPolicy` se configura inicialmente para permitir solicitudes sin autorización.

El ejemplo siguiente es el mismo que el ejemplo de `DefaultPolicy` anterior, pero usa el `FallbackPolicy` para requerir siempre autenticación en todos los extremos excepto cuando se especifica `[AllowAnonymous]`:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

La autorización por middleware funciona sin el marco de trabajo que tiene un conocimiento específico de la autorización. Por ejemplo, las [comprobaciones de estado](xref:host-and-deploy/health-checks) no tienen ningún conocimiento específico de la autorización, pero las comprobaciones de estado pueden tener una directiva de autorización configurable aplicada por el middleware.

Además, cada punto de conexión puede personalizar sus requisitos de autorización. En el ejemplo siguiente, `UseAuthorization` procesa la autorización con la `DefaultPolicy`, pero el extremo de comprobación de estado de `/healthz` requiere un usuario `admin`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

La protección se implementa en algunos escenarios. El middleware de extremos inicia una excepción si se omite una directiva de autorización o CORS debido a que falta un middleware. La compatibilidad con el analizador para proporcionar información adicional sobre la configuración inestable está en curso.

#### <a name="custom-authorization-handlers"></a>Controladores de autorización personalizados

Si la aplicación usa [controladores de autorización](xref:security/authorization/policies#authorization-handlers)personalizados, el enrutamiento del punto de conexión pasa un tipo de recurso diferente a los controladores que MVC. Los controladores que esperan que el recurso de contexto del controlador de autorización sea del tipo <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> (el tipo de recurso [proporcionado por los filtros de MVC](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)) deberán actualizarse para controlar los recursos de tipo <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> (el tipo de recurso dado a los controladores de autorización por enrutamiento de extremo).

MVC sigue usando `AuthorizationFilterContext` recursos, por lo que si la aplicación usa filtros de autorización MVC junto con la autorización de enrutamiento de punto de conexión, puede que sea necesario controlar ambos tipos de recursos.

### SignalR

La asignación de los concentradores de SignalR ahora tiene lugar dentro de `UseEndpoints`.

Asigne cada concentrador con `MapHub`. Como en versiones anteriores, cada concentrador aparece explícitamente en la lista.

En el ejemplo siguiente, se agrega compatibilidad con el concentrador de SignalR de `ChatHub`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Existe una nueva opción para controlar los límites de tamaño de los mensajes de los clientes. Por ejemplo, en `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

En ASP.NET Core 2,2, podría establecer el `TransportMaxBufferSize` y que controlaría de forma eficaz el tamaño máximo de los mensajes. En ASP.NET Core 3,0, esa opción ahora solo controla el tamaño máximo antes de que se observe la presión.

### <a name="mvc-controllers"></a>Controladores MVC

La asignación de controladores ahora tiene lugar dentro de `UseEndpoints`.

Agregue `MapControllers` si la aplicación usa el enrutamiento de atributos. Dado que el enrutamiento incluye compatibilidad con muchos marcos en ASP.NET Core 3,0 o posterior, la adición de controladores de enrutamiento de atributos es participación.

Reemplace lo siguiente:

* `MapRoute` con `MapControllerRoute`
* `MapAreaRoute` con `MapAreaControllerRoute`

Puesto que el enrutamiento ahora incluye compatibilidad con algo más que MVC, la terminología ha cambiado para que estos métodos indiquen claramente lo que hacen. Las rutas convencionales como `MapControllerRoute`/`MapAreaControllerRoute`/`MapDefaultControllerRoute` se aplican en el orden en que se agregan. Coloque primero rutas más específicas (por ejemplo, las rutas de un área).

En el ejemplo siguiente:

* `MapControllers` agrega compatibilidad con los controladores de enrutamiento de atributos.
* `MapAreaControllerRoute` agrega una ruta convencional para los controladores de un área.
* `MapControllerRoute` agrega una ruta convencional para los controladores.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Eliminación de sufijo asincrónico de los nombres de acción del controlador

En ASP.NET Core 3,0, ASP.NET Core MVC quita el sufijo `Async` de los nombres de acción del controlador. El enrutamiento y la generación de vínculos se ven afectados por este nuevo valor predeterminado. Por ejemplo:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Antes de ASP.NET Core 3,0:

* Se puede tener acceso a la acción anterior en la ruta *Products/ListAsync* .
* Generación de vínculos necesaria especificando el sufijo `Async`. Por ejemplo:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

En ASP.NET Core 3,0:

* Se puede tener acceso a la acción anterior en la ruta *Products/List* .
* La generación de vínculos no requiere especificar el sufijo `Async`. Por ejemplo:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Este cambio no afecta a los nombres especificados mediante el atributo [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) . El comportamiento predeterminado se puede deshabilitar con el código siguiente en `Startup.ConfigureServices`:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Cambios en la generación de vínculos

Como se explica en la documentación sobre [las diferencias con respecto a las versiones anteriores del enrutamiento](xref:fundamentals/routing#differences-from-earlier-versions-of-routing), existen algunas diferencias en la generación de vínculos (con `Url.Link` y API similares, por ejemplo). Entre ellas se incluyen las siguientes:

* De forma predeterminada, al usar el enrutamiento de punto de conexión, no se conservan las mayúsculas y minúsculas de los parámetros de ruta en los URI generados. Este comportamiento se puede controlar con la interfaz `IOutboundParameterTransformer`.
* La generación de un URI para una ruta no válida (controlador/acción o página que no existe) generará una cadena vacía en enrutamiento de punto de conexión en lugar de generar un URI no válido.
* Los valores de ambiente (parámetros de ruta del contexto actual) no se usan automáticamente en la generación de vínculos con el enrutamiento de puntos de conexión. Anteriormente, al generar un vínculo a otra acción (o página), los valores de ruta no especificados se deducen de los valores de ambiente de las rutas *actuales* . Al usar el enrutamiento de punto de conexión, todos los parámetros de ruta deben especificarse explícitamente durante la generación de vínculos.

### <a name="razor-pages"></a>Páginas de Razor

La asignación Razor Pages ahora tiene lugar dentro de `UseEndpoints`.

Agregue `MapRazorPages` si la aplicación usa Razor Pages. Dado que el enrutamiento del punto de conexión incluye compatibilidad con muchos marcos, agregar Razor Pages es ahora opcional.

En el siguiente método de `Startup.Configure`, `MapRazorPages` agrega compatibilidad con Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Uso de MVC sin enrutamiento de punto de conexión

El uso de MVC a través de `UseMvc` o `UseMvcWithDefaultRoute` en ASP.NET Core 3,0 requiere una participación explícita dentro de `Startup.ConfigureServices`. Esto es necesario porque MVC debe saber si puede confiar en la autorización y el middleware CORS durante la inicialización. Se proporciona un analizador que advierte si la aplicación intenta usar una configuración no admitida.

Si la aplicación requiere compatibilidad con `IRouter` heredado, deshabilite `EnableEndpointRouting` con cualquiera de los métodos siguientes en `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Comprobaciones de mantenimiento

Las comprobaciones de estado se pueden usar como un *enrutador* con enrutamiento de punto de conexión.

Agregue `MapHealthChecks` para usar las comprobaciones de estado con el enrutamiento de puntos de conexión. El método `MapHealthChecks` acepta argumentos similares a `UseHealthChecks`. La ventaja de usar `MapHealthChecks` sobre `UseHealthChecks` es la capacidad de aplicar la autorización y tener un control más preciso sobre la Directiva de coincidencia.

En el ejemplo siguiente, se llama a `MapHealthChecks` para un extremo de comprobación de estado en `/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder reemplaza a WebHostBuilder

Las plantillas ASP.NET Core 3,0 usan el [host genérico](xref:fundamentals/host/generic-host). Las versiones anteriores usaban el [host web](xref:fundamentals/host/web-host). En el código siguiente se muestra la plantilla ASP.NET Core 3,0 generada `Program` clase:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

En el código siguiente se muestra la clase `Program` generada por la plantilla ASP.NET Core 2,2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> permanece en 3,0 y es el tipo de la `webBuilder` que se ve en el ejemplo de código anterior. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> estará en desuso en una versión futura y se reemplazará por `HostBuilder`.

El cambio más significativo de `WebHostBuilder` a `HostBuilder` está en la [inserción de dependencias (di)](xref:fundamentals/dependency-injection). Cuando se usa `HostBuilder`, solo se puede insertar lo siguiente en el constructor de `Startup`:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

Las restricciones de `HostBuilder` DI:

* Habilite el contenedor de DI para que se compile solo una vez.
* Evita los problemas de duración de los objetos resultantes como resolver varias instancias de singleton.

Para obtener más información, consulte [evitar la inserción de servicios de inicio en ASP.net Core 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization se ha cambiado a otro ensamblado

Los métodos ASP.NET Core 2,2 y Lower `AddAuthorization` de *Microsoft. AspNetCore. Authorization. dll*:

* Se ha cambiado el nombre de `AddAuthorizationCore`.
* Se han migrado a *Microsoft. AspNetCore. Authorization. Policy. dll*.

Las aplicaciones que usan *Microsoft. AspNetCore. Authorization. dll* y *Microsoft. AspNetCore. Authorization. Policy. dll* no se ven afectadas.

Las aplicaciones que no usan *Microsoft. AspNetCore. Authorization. Policy. dll* deben realizar una de las siguientes acciones:

* Agregue una referencia a *Microsoft. AspNetCore. Authorization. Policy. dll*. Este enfoque funciona en la mayoría de las aplicaciones y es todo lo que se necesita.
* Cambiar a utilizar `AddAuthorizationCore`

Para obtener más información, vea [sobrecarga de cambios en `AddAuthorization(o =>`) que reside en un ensamblado diferente #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="identity-ui"></a>Interfaz de usuario de identidad

Actualizaciones de la interfaz de usuario de identidad para ASP.NET Core 3,0:

* Agregue una referencia de paquete a [Microsoft. AspNetCore. Identity. UI](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Las aplicaciones que no usan Razor Pages deben llamar a `MapRazorPages`. Consulte [Razor pages](#razor-pages) en este documento.
* Bootstrap 4 es el marco de interfaz de usuario predeterminado. Establezca una propiedad de proyecto de `IdentityUIFrameworkVersion` para cambiar el valor predeterminado. Para obtener más información, consulte [este anuncio de github](https://github.com/aspnet/Announcements/issues/380).

## SignalR

El cliente SignalR JavaScript ha cambiado de `@aspnet/signalr` a `@microsoft/signalr`. Para reaccionar a este cambio, cambie las referencias en los archivos *Package. JSON* , las instrucciones `require` y las instrucciones `import` de ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON es el protocolo predeterminado

`System.Text.Json` es ahora el protocolo de concentrador predeterminado utilizado por el cliente y el servidor.

En `Startup.ConfigureServices`, llame a `AddJsonProtocol` para establecer las opciones del serializador.

**Servidor**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Nº**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Cambiar a Newtonsoft. JSON

Si usa [características de Newtonsoft. JSON que no se admiten en System. Text. JSON](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to), puede volver a `Newtonsoft.Json`. Consulte [uso de Newtonsoft. JSON en un proyecto ASP.NET Core 3,0 SignalR](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) anteriormente en este artículo.

## <a name="redis-distributed-caches"></a>Memorias caché distribuidas en Redis

El paquete [Microsoft. Extensions. Caching. Redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) no está disponible para las aplicaciones ASP.net Core 3,0 o posteriores. Reemplace la referencia de paquete con [Microsoft. Extensions. Caching. StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis). Para más información, consulte <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Participar en la compilación en tiempo de ejecución

Antes de ASP.NET Core 3,0, la compilación de vistas en tiempo de ejecución era una característica implícita del marco. La compilación en tiempo de ejecución complementa la compilación en tiempo de compilación de las vistas. Permite al marco de trabajo compilar vistas y páginas de Razor (archivos *. cshtml* ) cuando se modifican los archivos, sin tener que volver a generar toda la aplicación. Esta característica admite el escenario de realizar una edición rápida en el IDE y actualizar el explorador para ver los cambios.

En ASP.NET Core 3,0, la compilación en tiempo de ejecución es un escenario de participación. La compilación en tiempo de compilación es el único mecanismo para la compilación de vistas que está habilitada de forma predeterminada. El Runtime se basa en Visual Studio o [dotnet-Watch](xref:tutorials/dotnet-watch) en Visual Studio Code para recompilar el proyecto cuando detecta cambios en los archivos *. cshtml* . En Visual Studio, los cambios en los archivos *. CS*, *. cshtml*o *. Razor* del proyecto que se ejecuta (<kbd>Ctrl + F5</kbd>), pero no se depuran (<kbd>F5</kbd>), desencadenan la recompilación del proyecto.

Para habilitar la compilación en tiempo de ejecución en el proyecto ASP.NET Core 3,0:

1. Instalar el paquete NuGet [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).
1. Actualice `Startup.ConfigureServices` para llamar a `AddRazorRuntimeCompilation`:

    Para ASP.NET Core MVC, use el código siguiente:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Para ASP.NET Core Razor Pages, use el siguiente código:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
En el ejemplo de https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation se muestra un ejemplo de cómo habilitar la compilación en tiempo de ejecución condicionalmente en entornos de desarrollo.

Para obtener más información sobre la compilación de archivos de Razor, consulte <xref:mvc/views/view-compilation>.

## <a name="migrate-libraries-via-multi-targeting"></a>Migración de bibliotecas a través de la compatibilidad con múltiples versiones

Las bibliotecas suelen necesitar admitir varias versiones de ASP.NET Core. La mayoría de las bibliotecas compiladas con versiones anteriores de ASP.NET Core deberían seguir funcionando sin problemas. Las condiciones siguientes requieren la compilación cruzada de la aplicación:

* La biblioteca se basa en una característica que tiene un [cambio de interrupción](#breaking-api-changes)binario.
* La biblioteca desea aprovechar las nuevas características de ASP.NET Core 3,0. 

Por ejemplo:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Use `#ifdefs` para habilitar API específicas de ASP.NET Core 3,0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Para obtener más información sobre el uso de ASP.NET Core API en una biblioteca de clases, vea <xref:fundamentals/target-aspnetcore>.

## <a name="miscellaneous-changes"></a>Cambios varios

El sistema de validación de .NET Core 3.0 y versiones posteriores trata las propiedades enlazadas o los parámetros que no aceptan valores NULL como si tuvieran un atributo `[Required]`. Para obtener más información, vea el [atributo [required]](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute).

### <a name="publish"></a>Publicar

Elimine las carpetas *bin* y *obj* en el directorio del proyecto.

## <a name="testserver"></a>TestServer

En el caso de las aplicaciones que usan <xref:Microsoft.AspNetCore.TestHost.TestServer> directamente con el [host genérico](xref:fundamentals/host/web-host), cree el `TestServer` en un <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> en <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A>:

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Interrupción de los cambios de API

Revisar cambios importantes:

* [Lista completa de cambios importantes en la versión ASP.NET Core 3,0](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Interrupción de los cambios de API en antifalsificación, CORS, diagnósticos, MVC y enrutamiento](https://github.com/aspnet/Announcements/issues/387). Esta lista incluye cambios importantes para los modificadores de compatibilidad.
* Para obtener un resumen de los cambios importantes de 2,2 a 3,0 en .NET Core, ASP.NET Core y Entity Framework Core, vea [cambios importantes para la migración de la versión 2,2 a la 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3,0 en Azure App Service

Para ver el progreso de la implementación de .NET Core en Azure App Service, consulte el sitio web oficial [de .net Core en App Service](https://aspnetcoreon.azurewebsites.net/) . Hasta que .NET Core 3,0 esté disponible en Azure App Service, siga las instrucciones de [Deploy ASP.net Core versión preliminar para Azure App Service](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).
