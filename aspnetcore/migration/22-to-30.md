---
title: Migrar de ASP.NET Core 2,2 a 3,0
author: rick-anderson
description: Obtenga información sobre cómo migrar un proyecto ASP.NET Core 2,2 a ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 09/29/2019
uid: migration/22-to-30
ms.openlocfilehash: 4259c11e1e186ea7488d53e326821de255aa2458
ms.sourcegitcommit: fe88748b762525cb490f7e39089a4760f6a73a24
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/30/2019
ms.locfileid: "71691196"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrar de ASP.NET Core 2,2 a 3,0

Por [Scott Addie](https://github.com/scottaddie) y [Rick Anderson](https://twitter.com/RickAndMSFT)

En este artículo se explica cómo actualizar un proyecto ASP.NET Core 2,2 existente a ASP.NET Core 3,0.

## <a name="prerequisites"></a>Requisitos previos

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio para Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Actualizar el archivo de proyecto

### <a name="update-the-target-framework"></a>Actualización de la plataforma de destino

ASP.NET Core 3,0 y versiones posteriores solo se ejecutan en .NET Core. Establezca el [moniker de la plataforma de destino (TFM)](/dotnet/standard/frameworks) en `netcoreapp3.0`:

```xml
<TargetFramework>netcoreapp3.0</TargetFramework>
```

### <a name="remove-obsolete-package-references"></a>Quitar referencias de paquetes obsoletas

ASP.NET Core ya no genera un gran número de características de paquetes NuGet. Estas referencias de paquete deben quitarse del archivo de proyecto. Para ver la lista completa de los paquetes que ya no se producen, vea a continuación:

<details>
    <summary>Haga clic aquí para expandir la lista de paquetes que ya no se generan</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.JwtBearer</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authentication.OpenIdConnect</li>
        <li>Microsoft.AspNetCore.Authorization</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Cryptography.Internal</li>
        <li>Microsoft.AspNetCore.Cryptography.KeyDerivation</li>
        <li>Microsoft.AspNetCore.DataProtection</li>
        <li>Microsoft.AspNetCore.DataProtection.Abstractions</li>
        <li>Microsoft.AspNetCore.DataProtection.Extensions</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.Http.Features</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.MiddlewareAnalysis</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.Extensions</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft.AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore.SignalR.Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net. http. Headers</li>
    </ul>
</details>

### <a name="framework-reference"></a>Referencia de Framework

Las características de ASP.net Core que estaban disponibles a través de uno de los paquetes enumerados anteriormente están disponibles `Microsoft.AspNetCore.App` como parte del marco de trabajo compartido. El *marco de trabajo compartido* es el conjunto de ensamblados (archivos *. dll* ) que se instalan en el equipo e incluye un componente de tiempo de ejecución y un paquete de destino. Para más información, consulte este artículo sobre el [marco de trabajo compartido](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Los proyectos que tienen `Microsoft.NET.Sdk.Web` como destino el SDK implícitamente hacen referencia al `Microsoft.AspNetCore.App` marco.

No se requieren referencias adicionales para estos proyectos:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>
    ...
</Project>
```

* Los proyectos que `Microsoft.NET.Sdk` tienen `Microsoft.NET.Sdk.Razor` como destino o SDK deben agregar `FrameworkReference` explícitamente a `Microsoft.AspNetCore.App`:

```xml
<Project Sdk="Microsoft.NET.Sdk.Razor">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>
    ...
</Project>
```

#### <a name="framework-dependent-builds-using-docker"></a>Compilaciones dependientes de Framework mediante Docker

Las compilaciones dependientes del marco de trabajo de aplicaciones de consola que usan un paquete que depende de la ASP.NET Core [marco compartido](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) pueden dar el siguiente error de tiempo de ejecución:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`es el marco de trabajo compartido que contiene el tiempo de ejecución de ASP.NET Core y solo está presente en la imagen de Docker [dotnet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) .  El SDK de 3,0 reduce el tamaño de las compilaciones dependientes del marco de trabajo mediante asp.net Core, sin incluir copias duplicadas de las bibliotecas que están disponibles en el marco de trabajo compartido.  Se trata de un ahorro potencial de hasta ~ 18MB pero requiere que el tiempo de ejecución de ASP.NET Core deba estar presente o instalado para ejecutar la aplicación.

Para determinar si la aplicación tiene una dependencia (directa o indirecta) en el ASP.NET Core marco compartido, examine el archivo *runtimeConfig. JSON* generado durante una compilación o publicación de la aplicación. El siguiente archivo JSON muestra una dependencia en el ASP.NET Core marco compartido:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Si la aplicación usa Docker, use una imagen base que incluya ASP.NET Core 3,0. Por ejemplo: `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Agregar referencias de paquete para los ensamblados quitados

ASP.net Core 3,0 quita algunos ensamblados que anteriormente formaban parte `Microsoft.AspNetCore.App` de la referencia de paquete. Para seguir usando las características proporcionadas por estos ensamblados, haga referencia a las versiones 3,0 de los paquetes correspondientes:

* [Microsoft. EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Para obtener más información sobre cómo hacer referencia al paquete específico del proveedor de bases de datos, vea [proveedores de bases de datos](/ef/core/providers/index).

* Interfaz de usuario de identidad

  Se puede Agregar compatibilidad con la [interfaz de usuario de identidad](xref:security/authentication/identity) haciendo referencia al paquete [Microsoft. AspNetCore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Servicios de SPA

  * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* La &ndash; compatibilidad con la autenticación para flujos de autenticación de terceros está disponible como paquetes NuGet:

  * OAuth de Facebook ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Token de portador de OpenID Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Autenticación de la cuenta Microsoft ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Autenticación de OpenID Connect ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Autenticación WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* La compatibilidad con la negociación de `System.Net.HttpClient` &ndash; contenido y el formato del paquete NuGet [Microsoft. Aspnet. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) proporciona `System.Net.HttpClient` una extensibilidad útil `ReadAsAsync`para `PostJsonAsync` con las API como, etc.

* La compatibilidad con &ndash; la compilación en tiempo de ejecución de Razor para la compilación en tiempo de ejecución de las vistas y páginas de Razor ahora forma parte de [Microsoft. AspNetCore. Mvc. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* La compatibilidad de MVC `Newtonsoft.Json` con el uso `Newtonsoft.Json` de MVC con ahora forma parte de [Microsoft. AspNetCore. Mvc. NewtonsoftJson.](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) &ndash;

### <a name="analyzer-support"></a>Compatibilidad con analizador

Los proyectos que `Microsoft.NET.Sdk.Web` tienen como destino los analizadores de referencia implícita anteriormente se incluyen como parte del paquete [Microsoft. AspNetCore. Mvc. analizadores](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . No se requieren referencias adicionales para habilitarlas.

Si su aplicación usa [analizadores de API](xref:web-api/advanced/analyzers) previamente enviados mediante el paquete [Microsoft. AspNetCore. Mvc. API. analizadores](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , edite el archivo de proyecto para que haga referencia a los analizadores que se incluyen como parte del SDK Web de .net Core:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Biblioteca de clases de Razor

Los proyectos de biblioteca de clases de Razor que proporcionan los componentes de `AddRazorSupportForMvc` interfaz de usuario para MVC deben establecer la propiedad en el archivo de proyecto:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Modelo de hospedaje en proceso

Los proyectos tienen como valor predeterminado el [modelo de hospedaje en proceso](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) en ASP.net Core 3,0 o posterior. Opcionalmente, puede quitar la `<AspNetCoreHostingModel>` propiedad en el archivo de proyecto si su valor `InProcess`es.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configuración

Migrar la configuración de Kestrel al generador de hosts `ConfigureWebHostDefaults` web proporcionado por (*Program.CS*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Si la aplicación crea el host manualmente con `HostBuilder`, llame `UseKestrel` a en el generador de host `ConfigureWebHostDefaults`Web en:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>El middleware de conexión reemplaza los adaptadores de conexión

Los adaptadores de conexión<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>() se han quitado de Kestrel. Reemplace los adaptadores de conexión por el middleware de conexión. El middleware de conexión es similar al middleware HTTP en la canalización de ASP.NET Core, pero para las conexiones de nivel inferior. HTTPS y registro de conexiones:

* Se han pasado de los adaptadores de conexión al middleware de conexión.
* Estos métodos de extensión funcionan como en versiones anteriores de ASP.NET Core. 

Para obtener más información, consulte [el ejemplo de TlsFilterConnectionHandler en la sección ListenOptions. Protocols del artículo Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Abstracciones de transporte que se movieron y hicieron públicas

La capa de transporte Kestrel se ha expuesto como una interfaz pública `Connections.Abstractions`en. Como parte de estas actualizaciones:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`y se han quitado los tipos asociados.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>se ha pasado <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> de a las opciones de transporte.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode>se ha quitado de <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>.

Para obtener más información, consulte los siguientes recursos de GitHub:

* [Abstracciones de redes cliente/servidor (#10308 ASPNET/AspNetCore)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Implementar una nueva abstracción de escucha de cimientos y volver a Kestrel en la parte superior (ASPNET/AspNetCore #10321)](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kestrel encabezados de finalizador de solicitud

En el caso de las aplicaciones destinadas a versiones anteriores de ASP.NET Core:

* Kestrel agrega encabezados de finalizador fragmentados de HTTP/1.1 a la colección de encabezados de solicitud.
* Los finalizadores están disponibles después de leer el cuerpo de la solicitud hasta el final.

Esto provoca algunos problemas sobre la ambigüedad entre encabezados y finalizadores, por lo que los finalizadores se han desplazado`RequestTrailerExtensions`a una nueva colección () en 3,0.

Los finalizadores de solicitudes HTTP/2 son:

* No disponible en ASP.NET Core 2,2.
* Disponible en 3,0 como `RequestTrailerExtensions`.

Hay nuevos métodos de extensión de solicitud para tener acceso a estos finalizadores. Al igual que con HTTP/1.1, los finalizadores están disponibles después de leer el cuerpo de la solicitud hasta el final.

Para la versión 3,0, están disponibles `RequestTrailerExtensions` los siguientes métodos:

* `GetDeclaredTrailers`Obtiene el encabezado `Trailer` de solicitud que muestra los finalizadores que se esperan después del cuerpo. &ndash;
* `SupportsTrailers`&ndash; Indica si la solicitud admite encabezados de finalizador de recepción.
* `CheckTrailersAvailable`&ndash; Comprueba si la solicitud admite finalizadores y si está disponible para su lectura. En esta comprobación no se da por hecho que hay finalizadores para leer. Es posible que no haya finalizaciones de lectura `true` aunque este método devuelva un resultado.
* `GetTrailer`&ndash; Obtiene el encabezado final solicitado de la respuesta. Compruebe `SupportsTrailers` antes de `GetTrailer`llamar a, <xref:System.NotSupportedException> o puede producirse si la solicitud no admite encabezados finales.

Para obtener más información, consulte [colocar finalizadores de solicitudes en una colección independiente (ASPNET/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO deshabilitado

`AllowSynchronousIO`habilita o deshabilita las API de e/s sincrónicas `HttpRequest.Body.Read`, `Stream.Flush`como, `HttpResponse.Body.Write`y. Estas API son un origen de colapso de subprocesos que conduce a bloqueos de la aplicación. En 3,0, `AllowSynchronousIO` está deshabilitado de forma predeterminada. Para obtener más información, consulte [la sección de e/s sincrónica en el artículo de Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Además de habilitar `AllowSynchronousIO` con `ConfigureKestrel`las opciones de, la e/s sincrónica también puede invalidarse por solicitud como una mitigación temporal:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Si tiene problemas con <xref:System.IO.TextWriter> las implementaciones u otras secuencias que llaman a las API sincrónicas en [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), llame a la nueva <xref:System.IO.Stream.DisposeAsync*> API en su lugar.

Para obtener más información, vea [[anuncio] AllowSynchronousIO deshabilitado en todos los servidores (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Se quitó el ensamblado Microsoft. AspNetCore. Server. Kestrel. https

En ASP.NET Core 2,1, el contenido de *Microsoft. AspNetCore. Server. Kestrel. https. dll* se ha migrado a *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. Se trata de una actualización no interrumpida `TypeForwardedTo` mediante atributos. En 3,0, se han quitado el ensamblado *Microsoft. AspNetCore. Server. Kestrel. https. dll* vacío (y el paquete NuGet).

Las bibliotecas que hacen referencia a [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) deben actualizar las dependencias ASP.NET Core a 2,1 o posterior.

Las aplicaciones y bibliotecas que tienen como destino ASP.NET Core 2,1 o posterior deben quitar las referencias directas al paquete [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

## <a name="jsonnet-support"></a>Compatibilidad con Json.NET

Como parte del trabajo para [mejorar la ASP.net Core marco compartido](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), se ha quitado [Json.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) de la ASP.net Core marco compartido.

El valor predeterminado para ASP.NET Core es ahora [System. Text. JSON](/dotnet/api/system.text.json?view=netcore-3.0), que es nuevo en .net Core 3,0. Considere la `System.Text.Json` posibilidad de usar cuando sea posible. Es de alto rendimiento y no requiere una dependencia de biblioteca adicional. Sin embargo, `System.Text.Json` como es nuevo, es posible que actualmente falten características que la aplicación necesita.

Es posible que la `Newtonsoft.Json` aplicación requiera la `Newtonsoft.Json`integración si usa una característica específica de, como JsonPatch o convertidores, o si [da formato](xref:web-api/advanced/formatting) `Newtonsoft.Json`a tipos específicos.

Para usar Json.NET en un proyecto de Signalr ASP.NET Core 3,0, consulte [cambiar a Newtonsoft. JSON](#switch-to-newtonsoftjson) en este documento.

Para usar Json.NET en un proyecto ASP.NET Core 3,0:

* Agregue una referencia de paquete a [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Actualización `Startup.ConfigureServices` que se `AddNewtonsoftJson`va a llamar.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`es compatible con los nuevos métodos de registro del servicio MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  La configuración de Json.NET se puede establecer en la `AddNewtonsoftJson`llamada a:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Registro del servicio MVC

ASP.NET Core 3,0 agrega nuevas opciones para registrar escenarios MVC en `Startup.ConfigureServices`.

Hay disponibles tres nuevos métodos de extensión de nivel superior relacionados con `IServiceCollection` los escenarios MVC en. Las plantillas usan estos nuevos métodos en lugar `UseMvc`de. Sin embargo `AddMvc` , continúa comportándose como tiene en versiones anteriores.

En el ejemplo siguiente se agrega compatibilidad con controladores y características relacionadas con la API, pero no vistas o páginas. La plantilla de API usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

En el ejemplo siguiente se agrega compatibilidad con controladores, características relacionadas con la API y vistas, pero no páginas. La plantilla aplicación web (MVC) utiliza este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

En el ejemplo siguiente se agrega compatibilidad con Razor Pages y compatibilidad mínima con el controlador. La plantilla de aplicación Web usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

También se pueden combinar los nuevos métodos. El ejemplo siguiente es equivalente a llamar `AddMvc` a en ASP.net Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Código de inicio de enrutamiento

Si una aplicación llama `UseMvc` a `UseSignalR`o, migre la aplicación al [enrutamiento del punto de conexión](xref:fundamentals/routing) , si es posible. Para mejorar la compatibilidad del enrutamiento de puntos de conexión con versiones anteriores de MVC, hemos revertido algunos de los cambios en la generación de direcciones URL introducidos en ASP.NET Core 2,2. Si experimenta problemas al usar el enrutamiento de puntos de conexión en 2,2, espere mejoras en ASP.NET Core 3,0 con las siguientes excepciones:

* Si la aplicación implementa `IRouter` o hereda de `Route`, use [DynamicRouteValuesTransformer](https://github.com/aspnet/AspNetCore.Docs/issues/12997) como reemplazo.

* Si la aplicación accede `RouteData.Routers` directamente a MVC para analizar las direcciones URL, puede reemplazarlo por el uso de. `LinkParser.ParsePathByEndpointName` 
 * Defina la ruta con un nombre de ruta.
 * Use `LinkParser.ParsePathByEndpointName` y pase el nombre de ruta deseado.

El enrutamiento de puntos de conexión admite la misma sintaxis de patrón de ruta y `IRouter`características de creación de patrones de ruta que. El enrutamiento del `IRouteConstraint`extremo admite. El enrutamiento del `[Route]`punto `[HttpGet]`de conexión admite, y los demás atributos de enrutamiento de MVC.

Para la mayoría de las `Startup` aplicaciones, solo requiere cambios.

### <a name="migrate-startupconfigure"></a>Migrar startup. Configure

Consejos generales:

* Agregar `UseRouting`.
* Si la aplicación llama `UseStaticFiles`a, `UseStaticFiles` Coloque **antes** `UseRouting`de.
* Si la aplicación usa características de autenticación/autorización como `AuthorizePage` o `[Authorize]`, coloque la llamada a `UseAuthentication` y `UseAuthorization`: **después**de `UseRouting` , `UseCors`y, pero `UseEndpoints`antes de:

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    }
  ```

* Reemplace `UseMvc` o `UseSignalR` por .`UseEndpoints`
* Si la aplicación usa escenarios de [CORS](xref:security/cors) , como `[EnableCors]`, coloque la llamada a `UseCors` antes de cualquier otro middleware que use CORS (por ejemplo, `UseCors` Coloque `UseAuthentication`antes `UseAuthorization`, y `UseEndpoints`).
* Reemplace `IHostingEnvironment` `using` <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> por `IWebHostEnvironment` y agregue una instrucción para el espacio de nombres.
* Reemplazar `IApplicationLifetime` por <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> espacio de nombres).
* Reemplazar `EnvironmentName` por <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> espacio de nombres).

El código siguiente es un ejemplo de `Startup.Configure` en una aplicación típica ASP.net Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Después de actualizar el `Startup.Configure` código anterior:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Para la mayoría de las aplicaciones `UseAuthentication`, `UseAuthorization`las llamadas `UseCors` a, y deben aparecer entre `UseRouting` las `UseEndpoints` llamadas a y para ser efectivas.

### <a name="health-checks"></a>Comprobaciones de estado

Las comprobaciones de estado usan el enrutamiento del punto de conexión con el host genérico. En `Startup.Configure`, llame a `MapHealthChecks` en el generador de puntos de conexiones con la dirección URL del punto de conexión o la ruta de acceso relativa:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Los extremos de las comprobaciones de estado pueden:

* Especifique uno o más hosts o puertos permitidos.
* Requerir autorización.
* Requerir CORS.

Para obtener más información, consulta <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Guía de middleware de seguridad

La compatibilidad con la autorización y CORS está unificada en torno al enfoque de [middleware](xref:fundamentals/middleware/index) . Esto permite el uso del mismo middleware y la misma funcionalidad en estos escenarios. En esta versión se proporciona un middleware de autorización actualizado, y el middleware CORS se ha mejorado para que pueda comprender los atributos usados por los controladores MVC.

#### <a name="cors"></a>CORS

Anteriormente, CORS podía ser difícil de configurar. El middleware se proporcionó para su uso en algunos casos de uso, pero los filtros de MVC debían usarse **sin** el middleware en otros casos de uso. Con ASP.NET Core 3,0, se recomienda que todas las aplicaciones que requieren CORS usen el middleware de CORS en tándem con el enrutamiento de puntos de conexión. `UseCors`se puede proporcionar con una directiva predeterminada, `[EnableCors]` y los atributos y `[DisableCors]` se pueden usar para invalidar la directiva predeterminada cuando sea necesario.

En el ejemplo siguiente:

* CORS está habilitado para todos los puntos de `default` conexión con la Directiva con nombre.
* La `MyController` clase deshabilita CORS con el `[DisableCors]` atributo.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorización

En versiones anteriores de ASP.net Core, se proporcionaba compatibilidad con la `[Authorize]` autorización mediante el atributo. El middleware de autorización no estaba disponible. En ASP.NET Core 3,0, se requiere middleware de autorización. Se recomienda colocar el middleware de autorización de`UseAuthorization`ASP.net Core () `UseAuthentication`inmediatamente después de. El middleware de autorización también puede configurarse con una directiva predeterminada, que se puede invalidar.

En ASP.net Core 3,0 o posterior, `UseAuthorization` se llama a `Startup.Configure`en, y lo `HomeController` siguiente requiere un usuario con sesión iniciada:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Si la aplicación usa `AuthorizeFilter` como filtro global en MVC, se recomienda refactorizar el código para proporcionar una directiva en la llamada a. `AddAuthorization`

`DefaultPolicy` Se configura inicialmente para requerir autenticación, por lo que no se requiere ninguna configuración adicional. En el ejemplo siguiente, los puntos de conexión de MVC `RequireAuthorization` se marcan como para que todas las solicitudes se `DefaultPolicy`deben autorizar en función de. Sin embargo, `HomeController` permite el acceso sin que el usuario inicie sesión en la `[AllowAnonymous]`aplicación debido a:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

También se pueden personalizar las directivas. Basándose en el ejemplo anterior, `DefaultPolicy` se configura para requerir autenticación y un ámbito específico:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Como alternativa, se pueden configurar todos los puntos de conexión para requerir `[Authorize]` la `RequireAuthorization` autorización sin o `FallbackPolicy`mediante la configuración de. `FallbackPolicy` Es diferente `DefaultPolicy`de. Se desencadena con `[Authorize]` `FallbackPolicy` o `RequireAuthorization`, mientras que se desencadena cuando no se establece ninguna otra directiva. `DefaultPolicy` `FallbackPolicy`está configurado inicialmente para permitir solicitudes sin autorización.

El ejemplo siguiente es el mismo que el anterior `DefaultPolicy` , pero `FallbackPolicy` usa para requerir siempre la autenticación en todos los extremos excepto cuando `[AllowAnonymous]` se especifica:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

La autorización por middleware funciona sin el marco de trabajo que tiene un conocimiento específico de la autorización. Por ejemplo, las [comprobaciones de estado](xref:host-and-deploy/health-checks) no tienen ningún conocimiento específico de la autorización, pero las comprobaciones de estado pueden tener una directiva de autorización configurable aplicada por el middleware.

Además, cada punto de conexión puede personalizar sus requisitos de autorización. En el ejemplo siguiente, `UseAuthorization` procesa la `DefaultPolicy`autorización con, pero el `/healthz` extremo de comprobación de estado `admin` requiere un usuario:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

La protección se implementa en algunos escenarios. `UseEndpoint`el middleware produce una excepción si se omite una directiva de autorización o CORS debido a que falta un middleware. La compatibilidad con el analizador para proporcionar información adicional sobre la configuración inestable está en curso.

### <a name="signalr"></a>SignalR

La asignación de los concentradores de Signalr `UseEndpoints`ahora tiene lugar dentro de.

Asigne cada concentrador `MapHub`con. Como en versiones anteriores, cada concentrador aparece explícitamente en la lista.

En el ejemplo siguiente, se agrega compatibilidad `ChatHub` con la central signalr:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Existe una nueva opción para controlar los límites de tamaño de los mensajes de los clientes. Por ejemplo, en `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

En ASP.net Core 2,2, puede establecer el y `TransportMaxBufferSize` el que controlarían de forma eficaz el tamaño máximo de los mensajes. En ASP.NET Core 3,0, esa opción ahora solo controla el tamaño máximo antes de que se observe la presión.

### <a name="mvc-controllers"></a>Controladores MVC

La asignación de controladores ahora tiene lugar `UseEndpoints`dentro de.

Agregue `MapControllers` si la aplicación usa el enrutamiento de atributos. Dado que el enrutamiento incluye compatibilidad con muchos marcos en ASP.NET Core 3,0 o posterior, la adición de controladores de enrutamiento de atributos es participación.

Reemplace lo siguiente:

* `MapRoute`Gracias`MapControllerRoute`
* `MapAreaRoute`Gracias`MapAreaControllerRoute`

Puesto que el enrutamiento ahora incluye compatibilidad con algo más que MVC, la terminología ha cambiado para que estos métodos indiquen claramente lo que hacen. Las rutas convencionales como `MapControllerRoute` / `MapAreaControllerRoute` se aplicanenelordenenqueseagregan./ `MapDefaultControllerRoute` Coloque primero rutas más específicas (por ejemplo, las rutas de un área).

En el ejemplo siguiente:

* `MapControllers`agrega compatibilidad con los controladores de enrutamiento de atributos.
* `MapAreaControllerRoute`agrega una ruta convencional para los controladores de un área.
* `MapControllerRoute`agrega una ruta convencional para los controladores.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Eliminación de sufijo asincrónico de los nombres de acción del controlador

En ASP.NET Core 3,0, ASP.NET Core MVC quita el sufijo `Async` de los nombres de acción del controlador. El enrutamiento y la generación de vínculos se ven afectados por este nuevo valor predeterminado. Por ejemplo:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Antes de ASP.NET Core 3,0:

* Se puede tener acceso a la acción anterior en la ruta *Products/ListAsync* .
* Generación de vínculos necesaria especificando el sufijo `Async`. Por ejemplo:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

En ASP.NET Core 3,0:

* Se puede tener acceso a la acción anterior en la ruta *Products/List* .
* La generación de vínculos no requiere especificar el sufijo `Async`. Por ejemplo:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Este cambio no afecta a los nombres especificados mediante el atributo [[ActionName]](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) . El comportamiento predeterminado se puede deshabilitar con el código siguiente en `Startup.ConfigureServices`:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

### <a name="razor-pages"></a>Páginas de Razor

La asignación Razor Pages ahora tiene lugar `UseEndpoints`dentro de.

Agregue `MapRazorPages` si la aplicación usa Razor pages. Dado que el enrutamiento del punto de conexión incluye compatibilidad con muchos marcos, agregar Razor Pages es ahora opcional.

En el método `Startup.Configure` siguiente, `MapRazorPages` agrega compatibilidad con Razor pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Uso de MVC sin enrutamiento de punto de conexión

El uso de `UseMvc` MVC `UseMvcWithDefaultRoute` a través de o en ASP.net Core 3,0 requiere una participación `Startup.ConfigureServices`explícita dentro de. Esto es necesario porque MVC debe saber si puede confiar en la autorización y el middleware CORS durante la inicialización. Se proporciona un analizador que advierte si la aplicación intenta usar una configuración no admitida.

Si la aplicación requiere compatibilidad `IRouter` heredada, `EnableEndpointRouting` deshabilite el uso de cualquiera de `Startup.ConfigureServices`los métodos siguientes en:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Comprobaciones de estado

Las comprobaciones de estado se pueden usar como un *enrutador* con enrutamiento de punto de conexión.

Agregue `MapHealthChecks` para usar comprobaciones de estado con enrutamiento de punto de conexión. El `MapHealthChecks` método acepta argumentos similares a `UseHealthChecks`. La ventaja de usar `MapHealthChecks` over `UseHealthChecks` es la capacidad de aplicar la autorización y tener un control más preciso sobre la Directiva de coincidencia.

En el ejemplo siguiente, `MapHealthChecks` se llama a para un extremo de comprobación `/healthz`de estado en:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder reemplaza a WebHostBuilder

Las plantillas ASP.NET Core 3,0 usan el [host genérico](xref:fundamentals/host/generic-host). Las versiones anteriores usaban el [host web](xref:fundamentals/host/web-host). En el código siguiente se muestra la clase generada `Program` de la plantilla ASP.net Core 3,0:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

En el código siguiente se muestra la clase generada `Program` por la plantilla ASP.net Core 2,2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>permanece en 3,0 y es el tipo del que `webBuilder` se ha detectado en el ejemplo de código anterior. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>quedará en desuso en una versión futura y se reemplazará por `HostBuilder`.

El cambio más significativo de `WebHostBuilder` a `HostBuilder` es en la [inserción de dependencias (di)](xref:fundamentals/dependency-injection). Cuando se `HostBuilder`usa, solo se puede <xref:Microsoft.Extensions.Configuration.IConfiguration> insertar <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> y `Startup`en el constructor de. Las `HostBuilder` restricciones de di:

* Habilite el contenedor de DI para que se compile solo una vez.
* Evita los problemas de duración de los objetos resultantes como resolver varias instancias de singleton.

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization se ha cambiado a otro ensamblado

Los métodos ASP.net Core 2,2 y `AddAuthorization` Lower de *Microsoft. AspNetCore. Authorization. dll*:

* Se ha cambiado `AddAuthorizationCore`el nombre.
* Se han migrado a *Microsoft. AspNetCore. Authorization. Policy. dll*.

Las aplicaciones que usan *Microsoft. AspNetCore. Authorization. dll* y *Microsoft. AspNetCore. Authorization. Policy. dll* no se ven afectadas.

Las aplicaciones que no usan *Microsoft. AspNetCore. Authorization. Policy. dll* deben realizar una de las siguientes acciones:

* Cambiar a con`AddAuthorizationCore`
* Agregue una referencia a *Microsoft. AspNetCore. Authorization. Policy. dll*.

Para obtener más información, vea [sobrecarga de `AddAuthorization(o =>`cambios en) en un ensamblado diferente #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr"></a>SignalR

El cliente de signalr JavaScript ha cambiado `@aspnet/signalr` de `@microsoft/signalr`a. Para reaccionar a este cambio, cambie las referencias en los archivos *Package. JSON* , `require` las `import` instrucciones y las instrucciones de ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON es el protocolo predeterminado

`System.Text.Json`es ahora el protocolo de concentrador predeterminado utilizado por el cliente y el servidor.

En `Startup.ConfigureServices`, llame `AddJsonProtocol` a para establecer las opciones del serializador.

**Servidor**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Nº**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Cambiar a Newtonsoft. JSON

Si utiliza características de `Newtonsoft.Json` que no se admiten en `System.Text.Json`, puede volver a: `Newtonsoft.Json`

1. Instale el paquete NuGet [Microsoft. AspNetCore. signalr. Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. En el cliente, encadenar una `AddNewtonsoftJsonProtocol` llamada de método a la `HubConnectionBuilder` instancia:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. En el servidor, encadenar una `AddNewtonsoftJsonProtocol` llamada de método a la `Startup.ConfigureServices` `AddSignalR` llamada al método en:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Participar en la compilación en tiempo de ejecución

En 3,0, la compilación en tiempo de ejecución es un escenario de participación. Para habilitar la compilación en tiempo <xref:mvc/views/view-compilation#runtime-compilation>de ejecución, vea.

## <a name="migrate-libraries-via-multi-targeting"></a>Migración de bibliotecas a través de la compatibilidad con múltiples versiones

Las bibliotecas suelen necesitar admitir varias versiones de ASP.NET Core. La mayoría de las bibliotecas compiladas con versiones anteriores de ASP.NET Core deberían seguir funcionando sin problemas. Las condiciones siguientes requieren la compilación cruzada de la aplicación:

* La biblioteca se basa en una característica que tiene un [cambio de interrupción](#breaking-api-changes)binario.
* La biblioteca desea aprovechar las nuevas características de ASP.NET Core 3,0. 

Por ejemplo:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Use `#ifdefs` para habilitar ASP.net Core API específicas de 3,0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#else if NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

## <a name="breaking-api-changes"></a>Interrupción de los cambios de API

* [Lista completa de cambios importantes en la versión ASP.NET Core 3,0](https://github.com/aspnet/Announcements/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Interrupción de los cambios de API en antifalsificación, CORS, diagnósticos, MVC y enrutamiento](https://github.com/aspnet/Announcements/issues/387). Esta lista incluye cambios importantes para los modificadores de compatibilidad.
* Para obtener un resumen de los cambios importantes de 2,2 a 3,0 en .NET Core, ASP.NET Core y Entity Framework Core, vea [cambios importantes para la migración de la versión 2,2 a la 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="aspnet-core-30-not-currently-available-for-azure-app-service"></a>ASP.NET Core 3,0 no está disponible actualmente para Azure App Service

Esperamos que esté disponible pronto. Hasta que ASP.NET Core 3,0 esté disponible en Azure App Service, siga las instrucciones de [Deploy ASP.net Core versión preliminar para Azure App Service](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).

## <a name="mysqldataentityframeworkcore-not-currently-supported-on-aspnet-core-30"></a>MySql. Data. EntityFrameworkCore no se admite actualmente en ASP.NET Core 3,0

Para obtener más información, consulte [este problema de GitHub](https://github.com/aspnet/EntityFrameworkCore/issues/17788).
