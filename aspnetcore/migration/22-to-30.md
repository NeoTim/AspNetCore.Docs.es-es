---
title: Migrar de ASP.NET Core 2.2 a 3.0
author: rick-anderson
description: Aprenda a migrar un proyecto de ASP.NET Core 2.2 a ASP.NET Core 3.0.
ms.author: riande
ms.custom: mvc
ms.date: 01/21/2020
no-loc:
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 46223011e82c7115147f59ee03e20d8033103b98
ms.sourcegitcommit: f0aeeab6ab6e09db713bb9b7862c45f4d447771b
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/08/2020
ms.locfileid: "80977241"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrar de ASP.NET Core 2.2 a 3.0

Por [Scott Addie](https://github.com/scottaddie) y [Rick Anderson](https://twitter.com/RickAndMSFT)

En este artículo se explica cómo actualizar un proyecto existente de ASP.NET Core 2.2 a ASP.NET Core 3.0.

## <a name="prerequisites"></a>Prerrequisitos

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Visual Studio para Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Actualización de la versión del SDK de .NET Core en global.json

Si la solución se basa en un archivo [global.json](/dotnet/core/tools/global-json) para `version` dirigirse a una versión específica del SDK de .NET Core, actualice su propiedad a la versión 3.0 instalada en el equipo:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Actualizar el archivo de proyecto

### <a name="update-the-target-framework"></a>Actualizar el marco de trabajo objetivo

ASP.NET Core 3.0 y versiones posteriores solo se ejecutan en .NET Core. Establezca el Moniker de marco `netcoreapp3.0`de [destino (TFM)](/dotnet/standard/frameworks) en:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Eliminar referencias de paquetes obsoletos

Un gran número de paquetes NuGet no se producen para ASP.NET Core 3.0. Estas referencias de paquete deben eliminarse del archivo de proyecto. Considere el siguiente archivo de proyecto para una aplicación web de ASP.NET Core 2.2:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

El archivo de proyecto actualizado para ASP.NET Core 3.0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

El archivo de proyecto ASP.NET Core 3.0 actualizado:

* En `<PropertyGroup>`:
  * Actualiza el TFM para`netcoreapp3.0`
  * Quita el `<AspNetCoreHostingModel>` elemento. Para obtener más información, consulte [Modelo de hospedaje en proceso](#in-process-hosting-model) en este documento.

* En `<ItemGroup>`:
  * `Microsoft.AspNetCore.App`se retira. Para obtener más información, consulte referencia de [marco](#framework-reference) en este documento.
  * `Microsoft.AspNetCore.Razor.Design`se elimina y en la siguiente lista de paquetes que ya no se producen.

Para ver la lista completa de paquetes que ya no se producen, seleccione la siguiente lista de expansión:

<details>
    <summary>Haga clic para expandir la lista de paquetes que ya no se están produciendo</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft.AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore. SignalR. Núcleo</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Revisar los cambios importantes

[Revisar los cambios importantes](#break)

### <a name="framework-reference"></a>Referencia marco

Las características de ASP.NET Core que estaban disponibles a `Microsoft.AspNetCore.App` través de uno de los paquetes enumerados anteriormente están disponibles como parte del marco compartido. El *marco compartido* es el conjunto de ensamblados (archivos *.dll*) que se instalan en la máquina e incluye un componente de entorno de ejecución y un paquete de destino. Para más información, consulte este artículo sobre el [marco de trabajo compartido](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Los proyectos que tienen como destino el SDK de `Microsoft.NET.Sdk.Web` hacen referencia implícitamente al marco `Microsoft.AspNetCore.App`.

  No se requieren referencias adicionales para estos proyectos:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Los proyectos `Microsoft.NET.Sdk` `Microsoft.NET.Sdk.Razor` que tienen como `FrameworkReference` destino `Microsoft.AspNetCore.App`o SDK, deben agregar un explícito a:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Compilaciones dependientes del marco de trabajo mediante Docker

Las compilaciones dependientes del marco de trabajo de aplicaciones de consola que usan un paquete que depende del [marco compartido](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) de ASP.NET Core puede dar el siguiente error en tiempo de ejecución:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`es el marco compartido que contiene el tiempo de ejecución de ASP.NET Core y solo está presente en la imagen de Docker [dotnet/core/aspnet.](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) El SDK 3.0 reduce el tamaño de las compilaciones dependientes del marco de trabajo mediante ASP.NET Core al no incluir copias duplicadas de bibliotecas que están disponibles en el marco compartido. Se trata de un ahorro potencial de hasta 18 MB, pero requiere que el tiempo de ejecución de ASP.NET Core esté presente / instalado para ejecutar la aplicación.

Para determinar si la aplicación tiene una dependencia (directa o indirecta) en el marco compartido de ASP.NET Core, examine el archivo *runtimeconfig.json* generado durante una compilación o publicación de la aplicación. El siguiente archivo JSON muestra una dependencia del marco compartido ASP.NET Core:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Si la aplicación usa Docker, usa una imagen base que incluya ASP.NET Core 3.0. Por ejemplo, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Agregar referencias de paquete para ensamblados eliminados

ASP.NET Core 3.0 quita algunos ensamblados que `Microsoft.AspNetCore.App` anteriormente formaban parte de la referencia del paquete. Para visualizar qué ensamblados se quitaron, compare las dos carpetas de marco de trabajo compartidas. Por ejemplo, una comparación de las versiones 2.2.7 y 3.0.0:

![comparación de asambleas de marcos compartidos](22-to-30/_static/assembly-diff.png)

Para seguir utilizando las características proporcionadas por los ensamblados eliminados, haga referencia a las versiones 3.0 de los paquetes correspondientes:

* Una aplicación web generada por plantilla con cuentas de **usuario individuales** requiere agregar los siguientes paquetes:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft.EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Para obtener más información sobre cómo hacer referencia al paquete específico del proveedor de base de datos, vea [Proveedores](/ef/core/providers/index)de base de datos .

* Interfaz de usuario de identidad

  La compatibilidad con la interfaz de usuario de [identidad](xref:security/authentication/identity) se puede agregar haciendo referencia al paquete [Microsoft.AspNetCore.Identity.UI.](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI)

* Servicios SPA

  * [Microsoft.AspNetCore.SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft.AspNetCore.SpaServices.Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* La &ndash; compatibilidad con la autenticación para flujos de autenticación de terceros está disponible como paquetes NuGet:

  * Facebook OAuth ([Microsoft.AspNetCore.Authentication.Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft.AspNetCore.Authentication.Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Autenticación de cuenta Microsoft ([Microsoft.AspNetCore.Authentication.MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Autenticación de OpenID Connect ([Microsoft.AspNetCore.Authentication.OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Token de portador de OpenID Connect ([Microsoft.AspNetCore.Authentication.JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft.AspNetCore.Authentication.Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Autenticación WsFederation ([Microsoft.AspNetCore.Authentication.WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Compatibilidad con el `System.Net.HttpClient` &ndash; formato y la negociación de contenido para el paquete `System.Net.HttpClient` NuGet [Microsoft.AspNet.WebApi.Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) proporciona una extensibilidad útil con API como `ReadAsAsync` y `PostJsonAsync`.

* Compilación en &ndash; tiempo de ejecución de Razor La compatibilidad con la compilación en tiempo de ejecución de vistas y páginas de Razor ahora forma parte de [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* La `Newtonsoft.Json` compatibilidad con &ndash; MVC (Json.NET) para usar MVC con `Newtonsoft.Json` ahora forma parte de [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>Cambios en la puesta en marcha

La siguiente imagen muestra las líneas eliminadas y modificadas en una aplicación web de ASP.NET Core 2.2 Razor Pages:

![las líneas eliminadas y modificadas en una aplicación web de ASP.NET Core 2.2 Razor](22-to-30/_static/startup2.2.png)

En la imagen anterior, el código eliminado se muestra en rojo. El código eliminado no muestra el código de las opciones de cookies, que se eliminó antes de comparar los archivos.

La siguiente imagen muestra las líneas agregadas y modificadas en una aplicación web de ASP.NET Core 3.0 Razor Pages:

![las líneas añadidas y cambiadas en una aplicación web de ASP.NET Core 3.0 Razor](22-to-30/_static/startup3.0.png)

En la imagen anterior, el código añadido se muestra en verde. Para obtener información sobre los siguientes cambios:

* `services.AddMvc`a `services.AddRazorPages`, vea el registro del [servicio MVC](#mvc-service-registration) en este documento.
* `CompatibilityVersion`, <xref:mvc/compatibility-version>véase .
* `IHostingEnvironment`a `IWebHostEnvironment`, vea este anuncio de [GitHub](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization`se agregó a las plantillas para mostrar el middleware de autorización de pedido que se debe agregar. Si la aplicación no usa autorización, puede `app.UseAuthorization`quitar de forma segura la llamada a .
* `app.UseEndpoints`, consulte [Razor Pages](#razor-pages) o [Migrate Startup.Configure](#migrate-startupconfigure) en este documento.

### <a name="analyzer-support"></a>Soporte del analizador

Los proyectos `Microsoft.NET.Sdk.Web` destinados implícitamente a analizadores se incluyen anteriormente como parte del paquete [Microsoft.AspNetCore.Mvc.Analyzers.](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) No se requieren referencias adicionales para habilitarlas.

Si la aplicación usa analizadores de [API suministrados](xref:web-api/advanced/analyzers) anteriormente mediante el paquete [Microsoft.AspNetCore.Mvc.Api.Analyzers,](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) edite el archivo de proyecto para hacer referencia a los analizadores incluidos como parte del SDK web de .NET Core:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Biblioteca de clases de Razor

Los proyectos de la biblioteca de clases de Razor que proporcionan componentes de interfaz de usuario para MVC deben establecer la `AddRazorSupportForMvc` propiedad en el archivo de proyecto:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Modelo de hospedaje en proceso

Los proyectos tienen como valor predeterminado el [modelo de hospedaje en proceso](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) en ASP.NET Core 3.0 o posterior. Opcionalmente, puede `<AspNetCoreHostingModel>` quitar la propiedad en el `InProcess`archivo de proyecto si su valor es .

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configuración

Migrar la configuración de Kestrel `ConfigureWebHostDefaults` al constructor de host web proporcionado por (*Program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Si la aplicación crea el `HostBuilder`host `UseKestrel` manualmente con , `ConfigureWebHostDefaults`llame al generador de host web en:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>El Middleware de conexión reemplaza a los adaptadores de conexión

Los adaptadores`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`de conexión ( ) se han eliminado de Kestrel. Reemplace los adaptadores de conexión por Middleware de conexión. El Middleware de conexión es similar al Middleware HTTP en la canalización ASP.NET Core, pero para conexiones de nivel inferior. HTTPS y registro de conexión:

* Se han movido de adaptadores de conexión a Middleware de conexión.
* Estos métodos de extensión funcionan como en versiones anteriores de ASP.NET Core. 

Para obtener más información, vea [el ejemplo TlsFilterConnectionHandler en la sección ListenOptions.Protocols del artículo Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Las abstracciones de transporte se trasladaron y se hicieron públicas

La capa de transporte de Kestrel se ha expuesto como una interfaz pública en `Connections.Abstractions`. Como parte de estas actualizaciones:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`y los tipos asociados se han eliminado.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>se trasladó de las opciones de <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> transporte.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode`fue retirado <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>de .

Para obtener más información, consulte los siguientes recursos de GitHub:

* [Abstracciones de redes cliente/servidor (#10308 dotnet/AspNetCore)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Implementar nueva abstracción de oyente sin ropa y volver a plat Kestrel en la parte superior (dotnet/AspNetCore #10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kestrel Solicitar cabeceras de remolque

Para aplicaciones destinadas a versiones anteriores de ASP.NET Core:

* Kestrel agrega encabezados de finalizador fragmentados HTTP/1.1 a la colección de encabezados de solicitud.
* Los remolques están disponibles después de leer el cuerpo de la solicitud hasta el final.

Esto causa algunas preocupaciones sobre la ambiguedad entre encabezados y remolques,`RequestTrailerExtensions`por lo que los remolques se han movido a una nueva colección ( ) en 3.0.

Los tráileres de solicitudes HTTP/2 son:

* No disponible en ASP.NET Core 2.2.
* Disponible en 3.0 como `RequestTrailerExtensions`.

Nuevos métodos de extensión de solicitud están presentes para acceder a estos trailers. Al igual que con HTTP/1.1, los trailers están disponibles después de leer el cuerpo de la solicitud hasta el final.

Para la versión 3.0, están disponibles los siguientes `RequestTrailerExtensions` métodos:

* `GetDeclaredTrailers`&ndash; Obtiene el `Trailer` encabezado de solicitud que enumera los finalizadores que se pueden esperar después del cuerpo.
* `SupportsTrailers`&ndash; Indica si la solicitud admite la recepción de encabezados de finalizador.
* `CheckTrailersAvailable`&ndash; Comprueba si la solicitud admite remolques y si están disponibles para ser leídos. Esta comprobación no supone que haya remolques para leer. Es posible que no haya `true` ningún finalizador para leer incluso si este método lo devuelve.
* `GetTrailer`&ndash; Obtiene el encabezado final solicitado de la respuesta. Compruebe `SupportsTrailers` antes `GetTrailer`de <xref:System.NotSupportedException> llamar a , o puede producirse a si la solicitud no admite encabezados finales.

Para obtener más información, vea Colocar finalizadores de [solicituden una colección independiente (dotnet/AspNetCore #10410).](https://github.com/dotnet/AspNetCore/pull/10410)

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO deshabilitado

`AllowSynchronousIO`habilita o deshabilita las API de E/S sincrónicas, como `HttpRequest.Body.Read`, `HttpResponse.Body.Write`, y `Stream.Flush`. Estas API son un origen de inanición de subprocesos que provoca bloqueos de aplicaciones. En la versión 3.0, `AllowSynchronousIO` se ha deshabilitado de manera predeterminada. Para obtener más información, consulte [la sección E/S sincrónica en el artículo de Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Si se necesita E/S sincrónica, se `AllowSynchronousIO` puede habilitar configurando la `ConfigureKestrel`opción en el servidor que se está utilizando (al llamar, por ejemplo, si se usa Kestrel). Tenga en cuenta que los servidores (Kestrel, HttpSys, `AllowSynchronousIO` TestServer, etc.) tienen su propia opción que no afectará a otros servidores. La E/S sincrónica se puede habilitar para todos `IHttpBodyControlFeature.AllowSynchronousIO` los servidores por solicitud mediante la opción:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Si tiene problemas <xref:System.IO.TextWriter> con las implementaciones u otras secuencias que <xref:System.IO.Stream.DisposeAsync*> llaman a las API sincrónicas en [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), llame a la nueva API en su lugar.

Para obtener más información, vea [[Anuncio] AllowSynchronousIO deshabilitado en todos los servidores (dotnet/AspNetCore #7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Microsoft.AspNetCore.Server.Kestrel.Https ensamblado quitado

En ASP.NET Core 2.1, el contenido de *Microsoft.AspNetCore.Server.Kestrel.Https.dll* se movió a *Microsoft.AspNetCore.Server.Kestrel.Core.dll*. Se trataba de una `TypeForwardedTo` actualización que no se interrumpió mediante atributos. Para 3.0, se han quitado el ensamblado *Microsoft.AspNetCore.Server.Kestrel.Https.dll* vacío y el paquete NuGet.

Las bibliotecas que hacen referencia a [Microsoft.AspNetCore.Server.Kestrel.Https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) deben actualizar ASP.NET dependencias principales a 2.1 o posterior.

Las aplicaciones y bibliotecas destinadas ASP.NET Core 2.1 o posterior deben quitar cualquier referencia directa al paquete [Microsoft.AspNetCore.Server.Kestrel.Https.](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https)

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Compatibilidad con Newtonsoft.Json (Json.NET)

Como parte del trabajo para [mejorar el marco compartido ASP.NET Core,](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/) [Newtonsoft.Json (Json.NET)](https://www.newtonsoft.com/json/help/html/Introduction.htm) se ha eliminado del marco compartido ASP.NET Core.

El serializador JSON predeterminado <xref:System.Text.Json>para ASP.NET Core es ahora, que es nuevo en .NET Core 3.0. Considere `System.Text.Json` usar cuando sea posible. Es de alto rendimiento y no requiere una dependencia de biblioteca adicional. Sin `System.Text.Json` embargo, dado que es nuevo, es posible que falten características que necesita la aplicación. Para obtener más información, consulte [Cómo migrar de Newtonsoft.Json a System.Text.Json](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-opno-locsignalr-project"></a>Utilice Newtonsoft.Json en un proyecto SignalR de ASP.NET Core 3.0

* Instale [Microsoft.AspNetCore.SignalR. Protocols.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) NuGet.

* En el cliente, `AddNewtonsoftJsonProtocol` encadene una llamada de método a la `HubConnectionBuilder` instancia:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chatHub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* En el servidor, `AddNewtonsoftJsonProtocol` encadene una llamada de método a la `AddSignalR` llamada al método en: `Startup.ConfigureServices`

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Use Newtonsoft.Json en un proyecto MVC de ASP.NET Core 3.0

* Instale el paquete [Microsoft.AspNetCore.Mvc.NewtonsoftJson.](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)

* Actualizar `Startup.ConfigureServices` para `AddNewtonsoftJson`llamar a .

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`es compatible con los nuevos métodos de registro de servicios MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json`los ajustes se pueden `AddNewtonsoftJson`establecer en la llamada a:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**Nota:** Si `AddNewtonsoftJson` el método no está disponible, asegúrese de que ha instalado el paquete [Microsoft.AspNetCore.Mvc.NewtonsoftJson.](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) Un error común es instalar el paquete [Newtonsoft.Json](https://www.nuget.org/packages/Newtonsoft.Json/) en lugar del paquete [Microsoft.AspNetCore.Mvc.NewtonsoftJson.](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)

## <a name="mvc-service-registration"></a>Registro de servicio MVC

ASP.NET Core 3.0 agrega nuevas opciones para `Startup.ConfigureServices`registrar escenarios MVC dentro de .

Hay disponibles tres nuevos métodos de `IServiceCollection` extensión de nivel superior relacionados con escenarios MVC. Las plantillas utilizan estos `AddMvc`nuevos métodos en lugar de . Sin `AddMvc` embargo, sigue comportándose como en versiones anteriores.

En el ejemplo siguiente se agrega compatibilidad con controladores y características relacionadas con la API, pero no para vistas ni páginas. La plantilla de API utiliza este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

En el ejemplo siguiente se agrega compatibilidad con controladores, características relacionadas con la API y vistas, pero no páginas. La plantilla de aplicación web (MVC) utiliza este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

En el ejemplo siguiente se agrega compatibilidad con Razor Pages y compatibilidad mínima con controladores. La plantilla de aplicación web utiliza este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Los nuevos métodos también se pueden combinar. El ejemplo siguiente equivale `AddMvc` a llamar a ASP.NET Core 2.2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Enrutamiento del código de inicio

Si una `UseMvc` aplicación `UseSignalR`llama o , migre la aplicación a [Endpoint Routing](xref:fundamentals/routing) si es posible. Para mejorar la compatibilidad de Endpoint Routing con versiones anteriores de MVC, hemos revertido algunos de los cambios en la generación de direcciones URL introducidas en ASP.NET Core 2.2. Si ha experimentado problemas al usar Endpoint Routing en 2.2, espere mejoras en ASP.NET Core 3.0 con las siguientes excepciones:

* Si la aplicación `IRouter` implementa o `Route`hereda de , use [DynamicRouteValuesTransformer](https://github.com/dotnet/AspNetCore.Docs/issues/12997) como reemplazo.
* Si la aplicación `RouteData.Routers` tiene acceso directamente dentro de MVC para analizar direcciones URL, puede reemplazarlo con el uso de [LinkParser.ParsePathByEndpointName](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*). 
  * Defina la ruta con un nombre de ruta.
  * Utilice `LinkParser.ParsePathByEndpointName` y pase el nombre de ruta deseado.

Endpoint Routing admite la misma sintaxis de `IRouter`patrón de ruta y las mismas características de creación de patrones de ruta que . Endpoint Routing `IRouteConstraint`admite . El enrutamiento `[Route]` `[HttpGet]`de punto final admite , y los demás atributos de enrutamiento MVC.

Para la mayoría `Startup` de las aplicaciones, solo requiere cambios.

### <a name="migrate-startupconfigure"></a>Migrar Startup.Configure

Consejos generales:

* Agregue `UseRouting`.
* Si la `UseStaticFiles`aplicación `UseStaticFiles` llama, colóquela **antes** `UseRouting`de .
* Si la aplicación utiliza características `AuthorizePage` de `[Authorize]`autenticación/autorización `UseAuthentication` `UseAuthorization`como o , coloque la llamada a y : **después**de , `UseRouting` y `UseCors`, pero antes `UseEndpoints`de:

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Reemplace `UseMvc` `UseSignalR` o `UseEndpoints`con .
* Si la aplicación usa escenarios [de CORS,](xref:security/cors) `[EnableCors]`como , coloque la llamada `UseCors` antes `UseCors` de `UseAuthentication` `UseAuthorization`cualquier `UseEndpoints`otro middleware que use CORS (por ejemplo, place before , , y ).
* Reemplace `IHostingEnvironment` `IWebHostEnvironment` con y `using` agregue <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> una instrucción para el espacio de nombres.
* Reemplazar `IApplicationLifetime` <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> por<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> ( espacio de nombres).
* Reemplazar `EnvironmentName` <xref:Microsoft.Extensions.Hosting.Environments> por<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> ( espacio de nombres).

El código siguiente es `Startup.Configure` un ejemplo de una aplicación típica de ASP.NET Core 2.2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Después de `Startup.Configure` actualizar el código anterior:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Para la mayoría `UseAuthentication`de `UseAuthorization`las `UseCors` aplicaciones, las `UseRouting` llamadas a , , y deben aparecer entre las llamadas y `UseEndpoints` para que sean eficaces.

### <a name="health-checks"></a>Comprobaciones de estado

Las comprobaciones de estado utilizan el enrutamiento de puntos de conexión con el host genérico. En `Startup.Configure`, llame a `MapHealthChecks` en el generador de puntos de conexiones con la dirección URL del punto de conexión o la ruta de acceso relativa:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Los puntos de conexión de las comprobaciones de estado pueden:

* Especificar uno o más hosts o puertos permitidos.
* Requerir autorización.
* Requerir CORS.

Para obtener más información, vea <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Guía de middleware de seguridad

La compatibilidad con la autorización y CORS se unifica en torno al enfoque de [middleware.](xref:fundamentals/middleware/index) Esto permite el uso del mismo middleware y funcionalidad en estos escenarios. En esta versión se proporciona un middleware de autorización actualizado y el Middleware de CORS se ha mejorado para que pueda comprender los atributos utilizados por los controladores MVC.

#### <a name="cors"></a>CORS

Anteriormente, CORS podía ser difícil de configurar. Middleware se proporcionó para su uso en algunos casos de uso, pero los filtros MVC estaban diseñados para usarse **sin** el middleware en otros casos de uso. Con ASP.NET Core 3.0, se recomienda que todas las aplicaciones que requieren CORS usen el Middleware de CORS junto con El enrutamiento de punto final. `UseCors`se puede proporcionar con una `[EnableCors]` `[DisableCors]` directiva predeterminada y los atributos se pueden usar para invalidar la directiva predeterminada cuando sea necesario.

En el ejemplo siguiente:

* CORS está habilitado para todos `default` los puntos de conexión con la directiva con nombre.
* La `MyController` clase deshabilita CORS `[DisableCors]` con el atributo.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

En versiones anteriores de ASP.NET Core, `[Authorize]` el soporte de autorización se proporcionaba a través del atributo. El middleware de autorización no estaba disponible. En ASP.NET Core 3.0, se requiere middleware de autorización. Recomendamos colocar el ASP.NET`UseAuthorization`Core Authorization `UseAuthentication`Middleware ( ) inmediatamente después de . El Middleware de la autorización también se puede configurar con una directiva predeterminada, que se puede invalidar.

En ASP.NET Core 3.0 `UseAuthorization` o `Startup.Configure`posterior, se `HomeController` llama en , y lo siguiente requiere un usuario que ha iniciado sesión:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Al usar el enrutamiento de `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` puntos de conexión, se recomienda no configurar y, en su lugar, confiar en el middleware de autorización.  Si la aplicación `AuthorizeFilter` usa un como filtro global en MVC, se recomienda refactorizar el código para proporcionar una directiva en la llamada a `AddAuthorization`.

El `DefaultPolicy` se configura inicialmente para requerir la autenticación, así que no se requiere ninguna configuración adicional. En el ejemplo siguiente, los `RequireAuthorization` extremos MVC se marcan como `DefaultPolicy`para que todas las solicitudes se deben autorizar en función del archivo . Sin `HomeController` embargo, permite el acceso sin `[AllowAnonymous]`que el usuario inicie sesión en la aplicación debido a:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Autorización para puntos finales específicos

La autorización también se puede configurar para clases específicas de puntos finales. El código siguiente es un ejemplo de conversión `AuthorizeFilter` de una aplicación MVC que configuró un global en una aplicación con una directiva específica que requiere autorización:

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

Las directivas también se pueden personalizar. El `DefaultPolicy` se configura para requerir la autenticación:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Alternativamente, todos los puntos finales `[Authorize]` `RequireAuthorization` se pueden `FallbackPolicy`configurar para requerir la autorización sin o configurando un archivo . El `FallbackPolicy` es diferente `DefaultPolicy`de la . El `DefaultPolicy` se `[Authorize]` desencadena `RequireAuthorization`por `FallbackPolicy` o , mientras que el se acciona cuando no se establece ninguna otra directiva. `FallbackPolicy`se configura inicialmente para permitir solicitudes sin autorización.

El ejemplo siguiente es el `DefaultPolicy` mismo que `FallbackPolicy` el ejemplo anterior, pero utiliza `[AllowAnonymous]` para requerir siempre la autenticación en todos los extremos excepto cuando se especifica:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

La autorización por middleware funciona sin que el marco tenga ningún conocimiento específico de la autorización. Por ejemplo, [las comprobaciones](xref:host-and-deploy/health-checks) de estado no tienen ningún conocimiento específico de la autorización, pero las comprobaciones de estado pueden tener una directiva de autorización configurable aplicada por el middleware.

Además, cada punto de conexión puede personalizar sus requisitos de autorización. En el ejemplo `UseAuthorization` siguiente, `DefaultPolicy`procesa la `/healthz` autorización con `admin` el archivo , pero el punto de conexión de comprobación de estado requiere un usuario:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

La protección se implementa para algunos escenarios. Middleware de puntos de conexión produce una excepción si se omite una directiva de autorización o CORS debido a la falta de middleware. Compatibilidad con el analizador para proporcionar comentarios adicionales sobre la configuración incorrecta está en curso.

#### <a name="custom-authorization-handlers"></a>Controladores de autorización personalizados

Si la aplicación usa controladores de [autorización personalizados,](xref:security/authorization/policies#authorization-handlers)el enrutamiento de extremos pasa un tipo de recurso diferente a los controladores que MVC. Los controladores que esperan que el <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> recurso de contexto del controlador de autorización sea de <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> tipo (el tipo de recurso proporcionado por los [filtros MVC)](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)deberá actualizarse para controlar los recursos de tipo (el tipo de recurso proporcionado a los controladores de autorización por enrutamiento de extremos).

MVC todavía `AuthorizationFilterContext` usa recursos, por lo que si la aplicación usa filtros de autorización MVC junto con la autorización de enrutamiento de extremo, puede ser necesario controlar ambos tipos de recursos.

### SignalR

La SignalR asignación de concentradores ahora tiene lugar dentro `UseEndpoints`de .

Asigne cada `MapHub`concentrador con . Al igual que en versiones anteriores, cada concentrador se enumera explícitamente.

En el ejemplo siguiente, `ChatHub` SignalR se agrega compatibilidad con el concentrador:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Hay una nueva opción para controlar los límites de tamaño de mensaje de los clientes. Por ejemplo, en `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

En ASP.NET Core 2.2, `TransportMaxBufferSize` podría establecer el y que controlaría eficazmente el tamaño máximo del mensaje. En ASP.NET Core 3.0, esa opción ahora solo controla el tamaño máximo antes de que se observe la contrapresión.

### <a name="mvc-controllers"></a>Controladores MVC

La asignación de `UseEndpoints`controladores ahora tiene lugar dentro de .

Agregue `MapControllers` si la aplicación usa el enrutamiento de atributos. Dado que el enrutamiento incluye compatibilidad con muchos marcos en ASP.NET Core 3.0 o posterior, la adición de controladores enrutados por atributos es opt-in.

Reemplace lo siguiente:

* `MapRoute` con `MapControllerRoute`
* `MapAreaRoute` con `MapAreaControllerRoute`

Dado que el enrutamiento ahora incluye compatibilidad con algo más que MVC, la terminología ha cambiado para que estos métodos indiquen claramente lo que hacen. Las rutas convencionales, como `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` las que se aplican en el orden en que se agregan. Coloque primero rutas más específicas (como rutas para un área).

En el ejemplo siguiente:

* `MapControllers`agrega compatibilidad con controladores enrutados por atributos.
* `MapAreaControllerRoute`añade una ruta convencional para los controladores en un área.
* `MapControllerRoute`añade una ruta convencional para los controladores.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Eliminación de sufijos asincrónicos de los nombres de acción del controlador

En ASP.NET Core 3.0, ASP.NET `Async` Core MVC quita el sufijo de los nombres de acción del controlador. El ruteo y la generación de links se ven afectados por este nuevo valor por defecto. Por ejemplo:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Antes de ASP.NET Core 3.0:

* Se pudo tener acceso a la acción anterior en la ruta *Products/ListAsync.*
* La generación de `Async` vínculos requiere especificar el sufijo. Por ejemplo:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

En ASP.NET Core 3.0:

* Se puede acceder a la acción anterior en la ruta *Productos/Lista.*
* La generación de vínculos `Async` no requiere especificar el sufijo. Por ejemplo:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Este cambio no afecta a los [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) nombres especificados mediante el atributo. El comportamiento predeterminado se puede deshabilitar `Startup.ConfigureServices`con el siguiente código en:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Cambios en la generación de enlaces

Como se explica en la documentación sobre [las diferencias con versiones anteriores de enrutamiento,](xref:fundamentals/routing#differences-from-earlier-versions-of-routing)hay algunas diferencias en la generación de vínculos (por ejemplo, el uso `Url.Link` y API similares). Se incluyen los siguientes:

* De forma predeterminada, cuando se utiliza el enrutamiento de punto final, la carcasa de los parámetros de ruta en los URI generados no se conserva necesariamente. Este comportamiento se puede `IOutboundParameterTransformer` controlar con la interfaz.
* Generar un URI para una ruta no válida (un controlador/acción o una página que no existe) producirá una cadena vacía en el enrutamiento de punto de conexión en lugar de producir un URI no válido.
* Los valores ambientales (parámetros de ruta del contexto actual) no se utilizan automáticamente en la generación de vínculos con el enrutamiento de punto final. Anteriormente, al generar un vínculo a otra acción (o página), los valores de ruta no especificados se deduceban de los valores ambientales de rutas *actuales.* Cuando se utiliza el enrutamiento de punto final, todos los parámetros de ruta deben especificarse explícitamente durante la generación de vínculos.

### <a name="razor-pages"></a>Páginas de Razor

La asignación de `UseEndpoints`páginas de Razor ahora tiene lugar dentro de .

Agregue `MapRazorPages` si la aplicación usa Razor Pages. Dado que Endpoint Routing incluye compatibilidad con muchos marcos, la adición de razor Pages ahora es opt-in.

En el `Startup.Configure` siguiente `MapRazorPages` método, agrega compatibilidad con Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Usar MVC sin enrutamiento de punto final

El uso `UseMvc` `UseMvcWithDefaultRoute` de MVC a través o en ASP.NET `Startup.ConfigureServices`Core 3.0 requiere una suscripción explícita dentro de . Esto es necesario porque MVC debe saber si puede confiar en la autorización y el Middleware de CORS durante la inicialización. Se proporciona un analizador que advierte si la aplicación intenta usar una configuración no compatible.

Si la aplicación `IRouter` requiere compatibilidad `EnableEndpointRouting` heredada, deshabilite cualquiera `Startup.ConfigureServices`de los siguientes enfoques en:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Comprobaciones de mantenimiento

Las comprobaciones de estado se pueden utilizar como *enrutador-ware* con Endpoint Routing.

Agregue `MapHealthChecks` para usar comprobaciones de estado con Endpoint Routing. El `MapHealthChecks` método acepta argumentos `UseHealthChecks`similares a . La ventaja `MapHealthChecks` de `UseHealthChecks` usar over es la capacidad de aplicar la autorización y tener un mayor control detallado sobre la directiva de coincidencia.

En el ejemplo `MapHealthChecks` siguiente, se llama `/healthz`a un punto de conexión de comprobación de estado en:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder reemplaza a WebHostBuilder

Las plantillas ASP.NET Core 3.0 utilizan [Host genérico.](xref:fundamentals/host/generic-host) Las versiones anteriores utilizaban [Web Host](xref:fundamentals/host/web-host). El código siguiente muestra la clase generada `Program` por la plantilla ASP.NET Core 3.0:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

El código siguiente muestra la clase generada `Program` por plantilla ASP.NET Core 2.2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>permanece en 3.0 y es `webBuilder` el tipo del visto en el ejemplo de código anterior. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>quedará en desuso en una `HostBuilder`versión futura y se reemplazará por .

El cambio más `WebHostBuilder` `HostBuilder` significativo de to es en [la inserción de dependencias (DI).](xref:fundamentals/dependency-injection) Cuando `HostBuilder`se utiliza , solo `Startup`se puede insertar lo siguiente en el constructor 's:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

Las `HostBuilder` restricciones DI:

* Habilite el contenedor DI para que se construya una sola vez.
* Evita los problemas de duración del objeto resultantes, como la resolución de varias instancias de singletons.

Para obtener más información, consulte Evitar la [inyección](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/)del servicio de inicio en ASP.NET Core 3 .

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization se movió a un ensamblado diferente

Los métodos ASP.NET Core `AddAuthorization` 2.2 y inferiores en *Microsoft.AspNetCore.Authorization.dll*:

* Se han `AddAuthorizationCore`cambiado el nombre .
* Se han movido a *Microsoft.AspNetCore.Authorization.Policy.dll*.

Las aplicaciones que utilizan *Microsoft.AspNetCore.Authorization.dll* y *Microsoft.AspNetCore.Authorization.Policy.dll* no se ven afectadas.

Las aplicaciones que no utilizan *Microsoft.AspNetCore.Authorization.Policy.dll* deben realizar una de las siguientes acciones:

* Agregue una referencia a *Microsoft.AspNetCore.Authorization.Policy.dll*. Este enfoque funciona para la mayoría de las aplicaciones y es todo lo que se requiere.
* Cambiar a usar`AddAuthorizationCore`

Para obtener más información, consulte [Interrupción del cambio en `AddAuthorization(o =>`) sobrecarga vive en un ensamblado diferente #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="identity-ui"></a>Interfaz de usuario de identidad

Actualizaciones de la interfaz de usuario de identidad para ASP.NET Core 3.0:

* Agregue una referencia de paquete a [Microsoft.AspNetCore.Identity.UI](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Las aplicaciones que no usan `MapRazorPages`Razor Pages deben llamar a . Consulte [Razor Pages](#razor-pages) en este documento.
* Bootstrap 4 es el marco de interfaz de usuario predeterminado. Establezca `IdentityUIFrameworkVersion` una propiedad de proyecto para cambiar el valor predeterminado. Para obtener más información, consulte este anuncio de [GitHub](https://github.com/aspnet/Announcements/issues/380).

## SignalR

El SignalR cliente JavaScript `@aspnet/signalr` ha `@microsoft/signalr`cambiado de a . Para reaccionar a este cambio, cambie las `require` referencias en archivos `import` *package.json,* instrucciones e instrucciones ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System.Text.Json es el protocolo predeterminado

`System.Text.Json`ahora es el protocolo DeHub predeterminado utilizado tanto por el cliente como por el servidor.

En `Startup.ConfigureServices`, `AddJsonProtocol` llame para establecer las opciones del serializador.

**Servidor:**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Cliente:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Cambiar a Newtonsoft.Json

Si utiliza [características de Newtonsoft.Json que no son compatibles con System.Text.Json](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to), puede volver a `Newtonsoft.Json`. Consulte [Usar Newtonsoft.Json en un SignalR proyecto de ASP.NET Core 3.0](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) anteriormente en este artículo.

## <a name="redis-distributed-caches"></a>Cachés distribuidas de Redis

El paquete [Microsoft.Extensions.Caching.Redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) no está disponible para aplicaciones ASP.NET Core 3.0 o posterior. Reemplace la referencia del paquete por [Microsoft.Extensions.Caching.StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis). Para obtener más información, vea <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Inscrípte en la compilación en tiempo de ejecución

Antes de ASP.NET Core 3.0, la compilación en tiempo de ejecución de vistas era una característica implícita del marco de trabajo. La compilación en tiempo de ejecución complementa la compilación en tiempo de compilación de vistas. Permite que el marco de trabajo compile vistas y páginas de Razor (archivos *.cshtml)* cuando se modifican los archivos, sin tener que volver a generar toda la aplicación. Esta característica admite el escenario de realizar una edición rápida en el IDE y actualizar el explorador para ver los cambios.

En ASP.NET Core 3.0, la compilación en tiempo de ejecución es un escenario de suscripción. La compilación en tiempo de compilación es el único mecanismo para la compilación de vistas que está habilitado de forma predeterminada. El tiempo de ejecución se basa en Visual Studio o [dotnet-watch](xref:tutorials/dotnet-watch) en Visual Studio Code para volver a generar el proyecto cuando detecta cambios en los archivos *.cshtml.* En Visual Studio, los cambios en los archivos *.cs*, *.cshtml*o *.razor* del proyecto que se está ejecutando (<kbd>Ctrl+F5</kbd>), pero no se depure (<kbd>F5</kbd>), desencadenan la recompilación del proyecto.

Para habilitar la compilación en tiempo de ejecución en el proyecto ASP.NET Core 3.0:

1. Instalar el paquete NuGet [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).
1. Actualización `Startup.ConfigureServices` para `AddRazorRuntimeCompilation`llamar a:

    Para ASP.NET Core MVC, use el código siguiente:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Para ASP.NET Core Razor Pages, utilice el siguiente código:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
El ejemplo https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation en muestra un ejemplo de habilitar la compilación en tiempo de ejecución condicionalmente en entornos de desarrollo.

Para obtener más información sobre <xref:mvc/views/view-compilation>la compilación de archivos Razor, consulte .

## <a name="migrate-libraries-via-multi-targeting"></a>Migrar bibliotecas a través de múltiples segmentaciones

Las bibliotecas a menudo necesitan admitir varias versiones de ASP.NET Core. La mayoría de las bibliotecas compiladas con versiones anteriores de ASP.NET Core deben seguir funcionando sin problemas. Las siguientes condiciones requieren que la aplicación se compile en cruz:

* La biblioteca se basa en una característica que tiene un cambio de [interrupción](#breaking-api-changes)binario.
* La biblioteca quiere aprovechar las nuevas características de ASP.NET Core 3.0. 

Por ejemplo:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Se `#ifdefs` utiliza para habilitar ASP.NET API específicas de Core 3.0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Para obtener más información sobre el uso de <xref:fundamentals/target-aspnetcore>ASP.NET API principales en una biblioteca de clases, consulte .

## <a name="miscellaneous-changes"></a>Cambios varios

El sistema de validación de .NET Core 3.0 y versiones posteriores trata las propiedades enlazadas o los parámetros que no aceptan valores NULL como si tuvieran un atributo `[Required]`. Para obtener más información, vea [[Requerido] atributo](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute).

### <a name="publish"></a>Publicar

Elimine las carpetas *bin* y *obj* del directorio del proyecto.

## <a name="testserver"></a>TestServer

Para las <xref:Microsoft.AspNetCore.TestHost.TestServer> aplicaciones que se utilizan `TestServer` directamente <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A>con el [host genérico](xref:fundamentals/host/web-host), cree el en un en :

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Romper los cambios en la API

Revisar los cambios importantes:

* [Lista completa de cambios importantes en la versión ASP.NET Core 3.0](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Romper los cambios de API en Antiforgery, CORS, Diagnostics, MVC y Routing](https://github.com/aspnet/Announcements/issues/387). Esta lista incluye cambios importantes para los modificadores de compatibilidad.
* Para obtener un resumen de los cambios de interrupción de 2.2 a 3.0 en .NET Core, ASP.NET Core y Entity Framework Core, vea [Interrumpir los cambios para la migración de la versión 2.2 a la 3.0](/dotnet/core/compatibility/2.2-3.0).

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3.0 en Azure App Service

Para ver el progreso en la implementación de .NET Core en Azure App Service, consulte el sitio web oficial de [.NET Core en App Service.](https://aspnetcoreon.azurewebsites.net/) Hasta que .NET Core 3.0 esté disponible en Azure App Service, siga las instrucciones de [Implementar ASP.NET versión preliminar principal](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service)en Azure App Service .
