---
title: Migración desde ASP.NET Core 2,2 a la versión preliminar de 3,0
author: tdykstra
description: Obtenga información sobre cómo migrar un proyecto ASP.NET Core 2,2 a ASP.NET Core 3,0.
ms.author: tdykstra
ms.custom: mvc
ms.date: 07/29/2019
uid: migration/22-to-30
ms.openlocfilehash: 4e20e4248957e3db796c7bbf85baf94fa263955b
ms.sourcegitcommit: 7001657c00358b082734ba4273693b9b3ed35d2a
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 07/31/2019
ms.locfileid: "68670062"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrar de ASP.NET Core 2,2 a 3,0

Por [Scott Addie](https://github.com/scottaddie) y [Rick Anderson](https://twitter.com/RickAndMSFT)

En este artículo se explica cómo actualizar un proyecto ASP.NET Core 2,2 existente a ASP.NET Core 3,0.

## <a name="prerequisites"></a>Requisitos previos

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio para Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Actualizar el archivo de proyecto

* Establezca el moniker de la plataforma de `netcoreapp3.0` [destino (TFM)](/dotnet/standard/frameworks) en:

  ```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
  ```

* Quite cualquier `<PackageReference>` del metapaquete [Microsoft. AspNetCore. All](xref:fundamentals/metapackage) o [Microsoft. AspNetCore. app](xref:fundamentals/metapackage-app) .

* Quite cualquier `<PackageReference>` del paquete [Microsoft. AspNetCore. Razor. Design](https://www.nuget.org/packages/Microsoft.AspNetCore.Razor.Design/) .

* Actualice el `Version` atributo en los `<PackageReference>` elementos restantes `Microsoft.AspNetCore.*` de los paquetes a la vista previa actual ( `3.0.0-preview5-19227-01`por ejemplo,).

  Si no hay ninguna versión 3,0 de un paquete, es posible que el paquete esté en desuso en 3,0. Muchos de estos paquetes forman parte de `Microsoft.AspNetCore.App` y no se debe hacer referencia a ellos de forma individual. Para obtener una lista preliminar de los paquetes que ya no se producen en 3,0, consulte [detener la generación de paquetes para ensamblados de marco compartidos en 3,0 (ASPNET/AspNetCore #3756)](https://github.com/aspnet/AspNetCore/issues/3756). El *marco de trabajo compartido* es el conjunto de ensamblados (archivos *. dll* ) que están instalados en el equipo y `Microsoft.AspNetCore.App`a los que hace referencia. Para más información, consulte este artículo sobre el [marco de trabajo compartido](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Los ensamblados de varios componentes importantes se quitaron de `Microsoft.AspNetCore.App` en 3,0. Agregue `<PackageReference>` elementos si usa las API de los paquetes enumerados en [ensamblados que se van a quitar de Microsoft. AspNetCore. app 3,0 (ASPNET/AspNetCore #3755)](https://github.com/aspnet/AspNetCore/issues/3755).

  Entre los ejemplos de componentes quitados se incluyen:

  * `Microsoft.AspNet.WebApi.Client`
  * `Microsoft.EntityFrameworkCore`
  * `System.Data.SqlClient`

  La lista de ensamblados que `Microsoft.AspNetCore.App` se distribuyen en no se ha finalizado y cambiará antes 3,0 RTM.

  Observe el código siguiente:

  ```csharp
  var branches = await response.Content.ReadAsAsync<IEnumerable<GitHubBranch>>();
  ```

  El `ReadAsAsync` método al que se llama en el código anterior `Microsoft.AspNet.WebApi.Client`se incluye en. Instale el paquete NuGet [Microsoft. Aspnet. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) para resolver el problema de compilación en 3,0.

* Agregue [compatibilidad con JSON.net](#jsonnet-support).

* Los proyectos tienen como valor predeterminado el [modelo de hospedaje en proceso](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) en ASP.net Core 3,0 o posterior. Opcionalmente, puede quitar la `<AspNetCoreHostingModel>` propiedad en el archivo de proyecto si su valor `InProcess`es.

## <a name="jsonnet-support"></a>Compatibilidad con Json.NET

Como parte del trabajo para [mejorar la ASP.net Core marco compartido](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), se ha quitado [Json.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) de la ASP.net Core marco compartido.

Para usar Json.NET en un proyecto ASP.NET Core 3,0:

* Agregue una referencia de paquete a [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Actualización `Startup.ConfigureServices` que se `AddNewtonsoftJson`va a llamar.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```
  
  `AddNewtonsoftJson`es compatible con los nuevos métodos de registro del servicio MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  La configuración de Json.NET se puede establecer en la `AddNewtonsoftJson`llamada a:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Registro del servicio MVC

ASP.NET Core 3,0 agrega nuevas opciones para registrar escenarios MVC en `Startup.ConfigureServices`.

Hay disponibles tres nuevos métodos de extensión de nivel superior relacionados con `IServiceCollection` los escenarios MVC en. Las plantillas usan estos nuevos métodos en lugar `UseMvc`de. Sin embargo `AddMvc` , continúa comportándose como tiene en versiones anteriores.

En el ejemplo siguiente se agrega compatibilidad con controladores y características relacionadas con la API, pero no vistas o páginas. La plantilla de API usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

En el ejemplo siguiente se agrega compatibilidad con controladores, características relacionadas con la API y vistas, pero no páginas. La plantilla aplicación web (MVC) utiliza este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

En el ejemplo siguiente se agrega compatibilidad con Razor Pages y compatibilidad mínima con el controlador. La plantilla de aplicación Web usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

También se pueden combinar los nuevos métodos. El ejemplo siguiente es equivalente a llamar `AddMvc` a en ASP.net Core 2,2: 

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
    services.AddRazorPages();
}
```

## <a name="update-routing-startup-code"></a>Actualizar código de inicio de enrutamiento

Si una aplicación llama `UseMvc` a `UseSignalR`o, migre la aplicación al [enrutamiento del punto de conexión](xref:fundamentals/routing) , si es posible. Para mejorar la compatibilidad del enrutamiento de puntos de conexión con versiones anteriores de MVC, hemos revertido algunos de los cambios en la generación de direcciones URL introducidos en ASP.NET Core 2,2. Si experimenta problemas al usar el enrutamiento de puntos de conexión en 2,2, espere mejoras en ASP.NET Core 3,0 con las siguientes excepciones:

* Si la aplicación implementa `IRouter` o hereda de `Route`, puede que desee evitar la migración en este momento. Proporcione comentarios en el [plan para migrar las implementaciones basadas en IRouter al enrutamiento del punto de conexión](https://github.com/aspnet/AspNetCore/issues/4221).

* Si la aplicación accede directamente a `RouteData.Routers` MVC, puede que desee evitar la migración en este momento. Proporcione comentarios en la [Guía de migración para el uso de RouteData.](https://github.com/aspnet/AspNetCore/issues/9148)enrutadores.

El enrutamiento de puntos de conexión admite la misma sintaxis de patrón de ruta y `IRouter`características de creación de patrones de ruta que. El enrutamiento del `IRouteContraint`extremo admite. El enrutamiento del `[Route]`punto `[HttpGet]`de conexión admite, y los demás atributos de enrutamiento de MVC.

Para la mayoría de las `Startup` aplicaciones, solo requiere cambios.

### <a name="migrate-startupconfigure"></a>Migrar startup. Configure

Consejos generales:

* Agregar `UseRouting`. 
* Si la aplicación llama `UseStaticFiles`a, `UseStaticFiles` Coloque **antes** `UseRouting`de.
* Si la aplicación usa características de autenticación y autorización como `AuthorizePage` o `[Authorize]`, coloque la llamada a `UseAuthentication` y `UseAuthorization` **después** `UseRouting`de.
* Si la aplicación usa características de [CORS](xref:security/cors) , como `[EnableCors]`, coloque `UseCors` Next.
* Reemplace `UseMvc` o `UseSignalR` por .`UseEndpoints`

El siguiente es un ejemplo de `Startup.Configure` en una aplicación típica de ASP.net Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();
    
    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Después de actualizar el `Startup.Configure` código anterior:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();
    
    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();
    app.UseCors();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="security-middleware-guidance"></a>Guía de middleware de seguridad

La compatibilidad con la autorización y CORS está unificada en torno al enfoque de [middleware](xref:fundamentals/middleware/index) . Esto permite el uso del mismo middleware y la misma funcionalidad en estos escenarios. En esta versión se proporciona un middleware de autorización actualizado, y el middleware CORS se ha mejorado para que pueda comprender los atributos usados por los controladores MVC.

#### <a name="cors"></a>CORS

Anteriormente, CORS podía ser difícil de configurar. El middleware se proporcionó para su uso en algunos casos de uso, pero los filtros de MVC debían usarse **sin** el middleware en otros casos de uso. Con ASP.NET Core 3,0, se recomienda que todas las aplicaciones que requieren CORS usen el middleware de CORS en tándem con el enrutamiento de puntos de conexión. `UseCors`se puede proporcionar con una directiva predeterminada, `[EnableCors]` y los atributos y `[DisableCors]` se pueden usar para invalidar la directiva predeterminada cuando sea necesario. 

En el ejemplo siguiente:

* CORS está habilitado para todos los puntos de `default` conexión con la Directiva con nombre.
* La `MyController` clase deshabilita CORS con el `[DisableCors]` atributo.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default"); 

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorización

En versiones anteriores de ASP.net Core, se proporcionaba compatibilidad con la `[Authorize]` autorización mediante el atributo. El middleware de autorización no estaba disponible. En ASP.NET Core 3,0, se requiere middleware de autorización. Se recomienda colocar el middleware de autorización de`UseAuthorization`ASP.net Core () `UseAuthentication`inmediatamente después de. El middleware de autorización también puede configurarse con una directiva predeterminada, que se puede invalidar.

En ASP.net Core 3,0 o posterior, `UseAuthorization` se llama a `Startup.Configure`en, y lo `HomeController` siguiente requiere un usuario con sesión iniciada:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Si la aplicación usa un `AuthorizeFilter` como filtro global en MVC, se recomienda refactorizar el código para proporcionar una directiva `UseAuthorization` al middleware.

En el ejemplo siguiente, se aplica una directiva personalizada a todas las solicitudes cuando `UseAuthorization` se llama a y el `HomeController` permite el acceso sin que el usuario inicie sesión en la aplicación:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization(new AuthorizationPolicyBuilder().Build()));

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

La autorización por middleware funciona sin el marco de trabajo que tiene un conocimiento específico de la autorización. Por ejemplo, las comprobaciones de [Estado](xref:host-and-deploy/health-checks) no tienen ningún conocimiento específico de la autorización, pero las comprobaciones de estado pueden tener una directiva de autorización configurable aplicada por el middleware.

En el ejemplo siguiente, `UseAuthorization` procesa la autorización sin una directiva predeterminada, pero `/healthz` el punto de conexión de comprobación de mantenimiento requiere que `admin` el usuario esté en el rol: 

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

La protección se implementa en algunos escenarios. `UseEndpoint`el middleware produce una excepción si se omite una directiva de autorización o CORS debido a que falta un middleware. La compatibilidad con el analizador para proporcionar información adicional sobre la configuración inestable está en curso.

### <a name="migrate-signalr"></a>Migración de Signalr

La asignación de los concentradores de Signalr `UseEndpoints`ahora tiene lugar dentro de. 

Asigne cada concentrador `MapHub`con. Como en versiones anteriores, cada concentrador aparece explícitamente en la lista.

En el ejemplo siguiente, se agrega compatibilidad `ChatHub` con la central signalr:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

### <a name="migrate-mvc-controllers"></a>Migrar controladores de MVC

La asignación de controladores ahora tiene lugar `UseEndpoints`dentro de. 

Agregue `MapControllers` si la aplicación usa el enrutamiento de atributos. Dado que el enrutamiento incluye compatibilidad con muchos marcos en ASP.NET Core 3,0 o posterior, la adición de controladores de enrutamiento de atributos es participación. 

Reemplace lo siguiente:

* `MapRoute`Gracias`MapControllerRoute`
* `MapAreaRoute`Gracias`MapAreaControllerRoute`

Puesto que el enrutamiento ahora incluye compatibilidad con algo más que MVC, la terminología ha cambiado para que estos métodos indiquen claramente lo que hacen. Las rutas convencionales como `MapControllerRoute` / `MapAreaControllerRoute` se aplicanenelordenenqueseagregan./ `MapDefaultControllerRoute` Coloque primero rutas más específicas (por ejemplo, las rutas de un área).

En el ejemplo siguiente:

* `MapControllers`agrega compatibilidad con los controladores de enrutamiento de atributos.
* `MapAreaControllerRoute`agrega una ruta convencional para los controladores de un área.
* `MapControllerRoute`agrega una ruta convencional para los controladores.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin", 
            "admin", 
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="migrate-razor-pages"></a>Migrar Razor Pages

La asignación Razor Pages ahora tiene lugar `UseEndpoints`dentro de.

Agregue `MapRazorPages` si la aplicación usa Razor pages. Dado que el enrutamiento del punto de conexión incluye compatibilidad con muchos marcos, agregar Razor Pages es ahora opcional.

En el ejemplo siguiente, `MapRazorPages` agrega compatibilidad con Razor pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Uso de MVC sin enrutamiento de punto de conexión

El uso de `UseMvc` MVC `UseMvcWithDefaultRoute` a través de o en ASP.net Core 3,0 requiere una participación `Startup.ConfigureServices`explícita dentro de. Esto es necesario porque MVC debe saber si puede confiar en la autorización y el middleware CORS durante la inicialización. Se proporciona un analizador que advierte si la aplicación intenta usar una configuración no admitida.

Si la aplicación requiere compatibilidad `IRouter` heredada, `EnableEndpointRouting` deshabilite el uso de cualquiera de `Startup.ConfigureServices`los métodos siguientes en:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="migrate-health-checks"></a>Migrar comprobaciones de estado

Las comprobaciones de estado se pueden usar como un enrutador con enrutamiento *de* punto de conexión.

Agregue `MapHealthChecks` para usar comprobaciones de estado con enrutamiento de punto de conexión. El `MapHealthChecks` método acepta argumentos similares a `UseHealthChecks`. La ventaja de usar `MapHealthChecks` over `UseHealthChecks` es la capacidad de aplicar la autorización y tener un control más preciso sobre la Directiva de coincidencia. 

En el ejemplo siguiente, `MapHealthChecks` se llama a para un extremo de comprobación `/healthz`de estado en:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder reemplaza a WebHostBuilder

Las plantillas ASP.NET Core 3,0 usan el [host genérico](xref:fundamentals/host/generic-host). Las versiones anteriores usaban el [host web](xref:fundamentals/host/web-host). En el código siguiente se muestra la clase generada `Program` de la plantilla ASP.net Core 3,0:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

En el código siguiente se muestra la clase generada `Program` por la plantilla ASP.net Core 2,2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>permanece en 3,0 y es el tipo del que `webBuilder` se ha detectado en el ejemplo de código anterior. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>quedará en desuso en una versión futura y se reemplazará por `HostBuilder`.

El cambio más significativo de `WebHostBuilder` a `HostBuilder` es en la [inserción de dependencias (di)](xref:fundamentals/dependency-injection). Cuando se `HostBuilder`usa, solo se puede <xref:Microsoft.Extensions.Configuration.IConfiguration> insertar <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> y `Startup`en el constructor de. Las `HostBuilder` restricciones de di:

* Habilite el contenedor de DI para que se compile solo una vez.
* Evita los problemas de duración de los objetos resultantes como resolver varias instancias de singleton.

## <a name="update-signalr-code"></a>Actualizar código de Signalr

`System.Text.Json`es ahora el protocolo de concentrador predeterminado utilizado por el cliente y el servidor.

En `Startup.ConfigureServices`, llame `AddJsonProtocol` a para establecer las opciones del serializador.

**Servidor**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Nº**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Cambiar a Newtonsoft. JSON

Si utiliza características de `Newtonsoft.Json` que no se admiten en `System.Text.Json`, puede volver a: `Newtonsoft.Json`

1. Instale el paquete NuGet [Microsoft. AspNetCore. signalr. Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. En el cliente, encadenar una `AddNewtonsoftJsonProtocol` llamada de método a la `HubConnectionBuilder` instancia:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. En el servidor, encadenar una `AddNewtonsoftJsonProtocol` llamada de método a la `Startup.ConfigureServices` `AddSignalR` llamada al método en:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Participar en la compilación en tiempo de ejecución

En 3,0, la compilación en tiempo de ejecución es un escenario de participación. Para habilitar la compilación en tiempo https://docs.microsoft.com/aspnet/core/mvc/views/view-compilation?view=aspnetcore-3.0#runtime-compilation de ejecución, vea.
